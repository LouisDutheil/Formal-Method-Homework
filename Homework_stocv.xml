<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>// Place global declarations here.
const int EMPTY = 0;
const int FIRE = 1;
const int EXIT = 2;

const int DRONE = 3;                //drones must not be placed on the grid with other entities because they're supposed to be able to hover over human entities (should not take room in the table)
const int FIRST_RESPONDER = 4;

const int SURVIVOR = 5;
const int SAFE = 6;
const int NEED = 7;
const int CIVILIAN = 8;
// const int N = 5;

/*********GLOBAL SYSTEM PARAMETERS *****************/

/* scenario 1 e 2 */
const int GRID_W = 5; //grid width
const int GRID_H = 5; //grid height
const int N_CIVILIANS = 4;  // Total number of civilians
const int N_DRONES = 2; //Total number of drones 
const int N_FR = 2; // Total number of first responders
const int Tv = 30; //time for the civilian to die close to a fire


/* scenario 3 
const int GRID_W = 8; //grid width
const int GRID_H = 6; //grid height
const int N_CIVILIANS = 6;  // Total number of civilians
const int N_DRONES = 3; //Total number of drones 
const int N_FR = 2; // Total number of first responders
const int Tv = 23; //time for the civilian to die close to a fire

*/
typedef int[0,N_CIVILIANS-1] id_zr;
typedef int[0,N_DRONES-1] id_dr;
typedef int[N_CIVILIANS,N_CIVILIANS+N_FR-1] id_fr;
typedef struct { int x, y; } pos_t;
const pos_t  DEF_POS = {-1, -1};

/********* VERIFICATION PARAMETERS *******************/

/* scenario 1 e 2 
int Tscs = 30;
int N_perc = 50;   // meaning 50%


/* scenario 3 */
int Tscs = 19;
int N_perc = 30;   // meaning %


/********* VERIFICATION VARIABLES *******************/

clock global_time;
int n_safe = 0; // n. of saved civilians

/*********GLOBAL VARIABLES*************************/

int grid[GRID_H][GRID_W];    // map considering role
// arrays used to put in relations ids with positions of entities (useful for drones too when contacting zero responders)
pos_t pos[N_CIVILIANS+N_FR];        // Array of coordinates of all civ+fr
pos_t posDrone[N_DRONES];

//todo remove int xNeed[GRID_H][GRID_W];   // X coordinate for need requests, xNeed[1][2] set to 5 indicates that the civilian found at coordinates (y=1,x=2) is in charge of saving the person in need found at x = 5  
//todo remove int yNeed[GRID_H][GRID_W];   // Y coordinate for need requests, --same-- at y = value

pos_t helping[N_CIVILIANS]; // helping {{1, 5}, {-1, -1}} means that civilian with id 0 is helping person found at coordinate x = 1 and y = 5 while civilian with id 1 is free
pos_t calling[N_CIVILIANS]; // calling {{1, 5}, {-1, -1}} means that civilian with id 0 is calling first responder found at coordinate x = 1 and y = 5 while civilian with id 1 is free
pos_t FRHelping[N_FR];      // same principles for first responders  


/*********GLOBAL VARIABLES*************************/

/*** CHANNELS *************************************/

broadcast chan assist[N_CIVILIANS]; // Channel used by drones to request survivors to assist
broadcast chan callFirstResponder[N_CIVILIANS]; //Channel used by drones to request survivors to call a first responder to help a person in need
broadcast chan assistDone[N_CIVILIANS+N_FR]; // Channel used by civilian when they're saved by a zero responder/first responder
broadcast chan starting;    // channel used from the initializer
broadcast chan dead[N_CIVILIANS];  // each victim use it to advise in case of death
broadcast chan wrong[N_CIVILIANS];

/*** CHANNELS *************************************/

/*** GLOBAL TYPES *********************************/



//...

/*** GLOBAL FUNCTIONS *************************************/

int cell(pos_t p) {
    return grid[p.y][p.x];
}

//Place the entity on the grid and register it in its respective array
void placeEntity(int id, int Y, int X, int entityType){
    if (entityType == FIRST_RESPONDER || entityType == CIVILIAN){
        grid[Y][X] = entityType;
        pos[id].x = X;
        pos[id].y = Y;
    }
    else if(entityType == DRONE){
        posDrone[id].x = X;
        posDrone[id].y = Y;
    }
    

}

void initCallingHelping(){
    int i;
    for(i=0;i&lt; N_CIVILIANS ;i++){
        helping[i]= DEF_POS;
        calling[i]= DEF_POS;
    }
}

void initFRHelping(){
    int i;
    for(i=0;i&lt; N_FR ;i++){
        FRHelping[i]= DEF_POS;
    }
}

/* scenario 1 e 2 */ 
void initializeGrid() {
    // Set all cells to EMPTY initially
    int i;
    for (i = 0; i &lt; GRID_W; i++) {
        int j;
        for (j = 0; j &lt; GRID_H; j++) {
            grid[j][i] = EMPTY;
        }
    }


    // Place exits in predefined positions
    grid[4][0] = EXIT;
    grid[4][4] = EXIT;

    //Place fire 
    grid[1][0] = FIRE;
    grid[0][4] = FIRE;
    grid[1][3] = FIRE;    
    grid[1][4] = FIRE;

    //Place Civilians
    placeEntity(0, 0, 1, CIVILIAN);
    placeEntity(1, 0, 3, CIVILIAN);
    placeEntity(2, 2, 0, CIVILIAN);
    placeEntity(3, 3, 4, CIVILIAN);

    //Place First Responders
    placeEntity(4, 2, 4, FIRST_RESPONDER);
    placeEntity(5, 4, 2, FIRST_RESPONDER);

    //Place Drones
    placeEntity(0, 0, 0, DRONE);
    placeEntity(1, 4, 3, DRONE);

    initCallingHelping();
    initFRHelping();
    n_safe=0;
}


/* scenario 3
void initializeGrid() {
    // Set all cells to EMPTY initially
    int i;
    for (i = 0; i &lt; GRID_W; i++) {
        int j;
        for (j = 0; j &lt; GRID_H; j++) {
            grid[j][i] = EMPTY;
        }
    }


    // Place exits in predefined positions
    grid[0][0] = EXIT;
    grid[1][0] = EXIT;
    grid[3][7] = EXIT;
    grid[4][7] = EXIT;

    //Place fire 
    grid[1][3] = FIRE;
    grid[1][4] = FIRE;
    grid[1][5] = FIRE;    
    grid[2][2] = FIRE;
    grid[2][3] = FIRE;
    grid[2][4] = FIRE;
    grid[3][2] = FIRE;
    grid[3][3] = FIRE;
    grid[3][4] = FIRE;
    grid[4][2] = FIRE;
    grid[5][2] = FIRE;

    //Place Civilians
    placeEntity(0, 0, 3, CIVILIAN);
    placeEntity(1, 0, 5, CIVILIAN);
    placeEntity(2, 0, 7, CIVILIAN);
    placeEntity(3, 2, 1, CIVILIAN);
    placeEntity(4, 4, 4, CIVILIAN);
    placeEntity(5, 4, 1, CIVILIAN);

    //Place First Responders
    placeEntity(6, 3, 0, FIRST_RESPONDER);
    placeEntity(7, 2, 5, FIRST_RESPONDER);

    //Place Drones
    placeEntity(0, 0, 0, DRONE);
    placeEntity(1, 0, 3, DRONE);
    placeEntity(2, 0, 5, DRONE);

    initCallingHelping();
    initFRHelping();
    n_safe=0;
}*/

int abs_(int x) {
  if (x &lt; 0) {
    return -x;
  }
  return x;
}

/**
 * @brief Given coordinates x,y search in pos array to get the id of the civilian
 *
 * @param x The x-coordinate.
 * @param y The y-coordinate.
 * @return id of the specific entity.
 */
int getIdFromPosCivilian(pos_t posCiv){
   int i;
   for(i=0;i&lt;N_CIVILIANS;i++){
       if(pos[i].x== posCiv.x &amp;&amp; pos[i].y== posCiv.y){
         return i;
        }    
    }
    return -1;
}

/**
 * @brief Given coordinates x,y search in pos array to get the id of the first responder
 *
 * @param x The x-coordinate.
 * @param y The y-coordinate.
 * @return id of the specific entity.
 */
int getIdFromPosFirstResponder(pos_t posFR){
    int i;
    for(i=N_CIVILIANS;i&lt;N_CIVILIANS+N_FR;i++){
       if(pos[i].x== posFR.x &amp;&amp; pos[i].y== posFR.y){
         return i;
        }    
    }
    return -1;
}

bool reached_Tscs() {
    if(global_time &gt;= Tscs){ return true;}
    return false;
}


</declaration>
	<template>
		<name>Initializer</name>
		<location id="id0" x="0" y="0">
			<name x="-10" y="-34">Initial</name>
			<committed/>
		</location>
		<location id="id1" x="0" y="119">
		</location>
		<init ref="id0"/>
		<transition id="id2">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="0" y="42">starting!</label>
			<label kind="assignment" x="0" y="59">initializeGrid()</label>
		</transition>
	</template>
	<template>
		<name>FirstResponder</name>
		<parameter>const id_fr id,int Tfr</parameter>
		<declaration>clock x;
int idRescuing; // id person we're rescuing
int waiting; // distance from person in need when zr called
int zrToCommTo; // id zr to contact when finishing Tfr

/**
 * @brief Checks if a position is valid within the grid bounds.
 *
 * @param x The x-coordinate to check.
 * @param y The y-coordinate to check.
 * @return true if the position is valid, false otherwise.
 */
bool isValid(int x, int y) {
    if(x &gt;= 0 &amp;&amp; x &lt; GRID_W-1 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; GRID_H-1){
        return true;
    }
    return false;
}

/**
 * @brief Checks if a position is near fire.
 *
 * @param x The x-coordinate to check.
 * @param y The y-coordinate to check.
 * @return true if the position is near fire, false otherwise.
 */
bool isFireNear(int x, int y) {
    const int DX[4] = {-1, 1, 0, 0}; // Up, Down
    const int DY[4] = {0, 0, -1, 1}; // Left, Right
    int i;

    for (i = 0; i &lt; 4; i++) {
        int nx = x + DX[i];
        int ny = y + DY[i];

        if (isValid(nx, ny) &amp;&amp; grid[ny][nx] == FIRE) {
            return true;
        }
    }
    return false;
}
/**
 * @brief Checks if a position is near to a person in need.
 *
 * @param x The x-coordinate to check.
 * @param y The y-coordinate to check.
 * @return true if the position is near a person in need, false otherwise.
 */
bool isNeedNear(pos_t posNeed) {
    const int DX[4] = {-1, 1, 0, 0}; // Up, Down
    const int DY[4] = {0, 0, -1, 1}; // Left, Right
    int i;

    for (i = 0; i &lt; 4; i++) {
        int nx = posNeed.x + DX[i];
        int ny = posNeed.y + DY[i];

        if (isValid(nx, ny) &amp;&amp; grid[ny][nx] == NEED) {
            return true;
        }
    }
    return false;
}

void saveIdRescuing(pos_t posResc){
    const int DX[4] = {-1, 1, 0, 0}; // Up, Down
    const int DY[4] = {0, 0, -1, 1}; // Left, Right
    int i;

    for (i = 0; i &lt; 4; i++) {
        int nx = posResc.x + DX[i];
        int ny = posResc.y + DY[i];
        pos_t newPos = {nx, ny};
        if (isValid(nx, ny) &amp;&amp; grid[ny][nx] == NEED) {
            FRHelping[id-N_CIVILIANS].x= nx;
            FRHelping[id-N_CIVILIANS].y= ny;
            idRescuing = getIdFromPosCivilian(newPos);
        }
    }
}


bool isInCalling(){
   pos_t posFR = pos[id];
   int i;
   for(i=0;i&lt;N_CIVILIANS;i++){
      if(calling[i] == posFR){
            return true;   
     }
    }
    return false;
}
/**
 * @brief Moves a first responder to the center of the grid
 *
 * This function attempts to move a first responder (identified by `id`) towards the nearest edge of the grid.
 * The movement is restricted to horizontal or vertical directions and ensures that the new position is
 * not near fire. The function checks each step to determine if the new position is valid.
 *
 * @param id The identifier of the civilian to be moved.
 */
void move(int id) {
    // Current position of the civilian
    int current_x = pos[id].x;
    int current_y = pos[id].y;
    int new_x;
    int new_y;

    // Determine the distances to each side of the grid
    int dist_top = current_y;
    int dist_bottom = GRID_H - 1 - current_y;
    int dist_left = current_x;
    int dist_right = GRID_W - 1 - current_x;
    bool change;

    // Determine the direction going near the center
    int max_dist = 0;
    int direction = 0; // 0 for top, 1 for bottom, 2 for left, 3 for right

    if(isInCalling()){  change=1;}
    else change=0;

    if (dist_top &gt; max_dist &amp;&amp; grid[current_y - 1][current_x]!= FIRE ) {
        max_dist = dist_top;
        direction = 0;
    }
    if (dist_bottom &gt; max_dist &amp;&amp; grid[current_y + 1][current_x]!= FIRE ) {
        max_dist = dist_bottom;
        direction = 1;
    }
    if (dist_left &gt; max_dist &amp;&amp; grid[current_y][current_x-1]!= FIRE) {
        max_dist = dist_left;
        direction = 2;
    }
    if (dist_right &gt; max_dist &amp;&amp; grid[current_y][current_x+1]!= FIRE) {
        max_dist = dist_right;
        direction = 3;
    }

    new_x = current_x;
    new_y = current_y;

    // Move in the direction of the nearest side
    if (direction == 0) {
        // Move up
        new_y = current_y - 1;
    } else if (direction == 1) {
        // Move down
        new_y = current_y + 1;
    } else if (direction == 2) {
        // Move left
        new_x = current_x - 1;
    } else if (direction == 3) {
        // Move right
        new_x = current_x + 1;
     
    }

    // Check if the new position is valid and not near fire
    if (new_x &gt;= 0 &amp;&amp; new_x &lt; GRID_W &amp;&amp; new_y &gt;= 0 &amp;&amp; new_y &lt; GRID_H &amp;&amp; change==0) {
        if (grid[new_y][new_x] == EMPTY) {
            pos[id].x = new_x;
            pos[id].y = new_y;
            grid[current_y][current_x] = EMPTY;
            grid[new_y][new_x] = FIRST_RESPONDER; //update the grid
        }
    }
    
}

/**
 * @brief Calculates the Manhattan distance of a fr to the specified destination.
 *
 * This function calculates the Manhattan distance from the fr's current position
 * to the specified destination (destx, desty).
 *
 * @param id The identifier of the civilian.
 * @param dest The position of the destination.
 * @return The Manhattan distance to the destination.
 */
int calculateDistance(int id, pos_t dest) {
    // Current position of the civilian
    pos_t current_pos = pos[id];

    // Calculate Manhattan distance
    int distance = abs(current_pos.x - dest.x) + abs(current_pos.y - dest.y);

    return distance;
}


bool differentPerson(){
   pos_t pos_rescue;
    pos_t posFR = pos[id];
   int i;
   for(i=0;i&lt;N_CIVILIANS;i++){
      if(calling[i] == posFR){
            pos_rescue = helping[i];   
     }
    }
    i = getIdFromPosCivilian(pos_rescue);
    if( idRescuing == i){ return false;}
    return true;
}


void setWaiting(pos_t posFR){
   pos_t pos_rescue;
   int i;
   for(i=0;i&lt;N_CIVILIANS;i++){
      if(calling[i] == posFR){
            pos_rescue = helping[i];
            FRHelping[id-N_CIVILIANS].x= pos_rescue.x;
            FRHelping[id-N_CIVILIANS].y= pos_rescue.y;
            zrToCommTo = i;     
     }
    } 
   waiting = abs(calculateDistance(id,pos_rescue));
}

void setFRFree(int id){
    int i = id - N_CIVILIANS;
    FRHelping[i] = DEF_POS;
}</declaration>
		<location id="id3" x="8" y="0">
			<name x="-2" y="-34">Initial</name>
			<label kind="invariant" x="-2" y="17">x&lt;=Tv</label>
		</location>
		<location id="id4" x="-391" y="0">
			<name x="-442" y="-34">Rescue_person</name>
			<label kind="invariant" x="-416" y="17">x&lt;=Tfr</label>
		</location>
		<location id="id5" x="654" y="0">
			<name x="644" y="-34">Called</name>
			<label kind="invariant" x="644" y="17">x&lt;=waiting</label>
		</location>
		<location id="id6" x="654" y="178">
			<label kind="invariant" x="644" y="195">x&lt;=Tfr</label>
		</location>
		<location id="id7" x="229" y="-93">
			<name x="219" y="-127">Initializer</name>
		</location>
		<location id="id8" x="-34" y="-289">
			<label kind="invariant" x="-44" y="-272">x&lt;=Tfr</label>
		</location>
		<location id="id9" x="42" y="178">
			<committed/>
		</location>
		<location id="id10" x="-136" y="-212">
			<committed/>
		</location>
		<location id="id11" x="-272" y="229">
			<name x="-282" y="195">End</name>
			<label kind="invariant" x="-282" y="246">x&gt;=Tv</label>
		</location>
		<init ref="id7"/>
		<transition id="id12">
			<source ref="id4"/>
			<target ref="id3"/>
			<label kind="guard" x="-347" y="34">x&gt;=Tfr</label>
			<label kind="synchronisation" x="-347" y="51">assistDone[idRescuing]!</label>
			<label kind="assignment" x="-347" y="68">move(id),setFRFree(id)</label>
			<nail x="-365" y="68"/>
			<nail x="-161" y="68"/>
		</transition>
		<transition id="id13">
			<source ref="id3"/>
			<target ref="id11"/>
			<label kind="guard" x="-229" y="144">x&gt;=Tv</label>
		</transition>
		<transition id="id14">
			<source ref="id6"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="391" y="102">dead[idRescuing]?</label>
			<label kind="assignment" x="442" y="119">setFRFree(id)</label>
			<nail x="280" y="102"/>
			<nail x="76" y="102"/>
		</transition>
		<transition id="id15">
			<source ref="id10"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="-119" y="-204">wrong[zrToCommTo]!</label>
		</transition>
		<transition id="id16">
			<source ref="id8"/>
			<target ref="id10"/>
			<label kind="guard" x="-297" y="-280">x&gt;=Tfr &amp;&amp; !differentPerson()</label>
			<label kind="synchronisation" x="-289" y="-263">assistDone[idRescuing]!</label>
			<label kind="assignment" x="-272" y="-246">setFRFree(id)</label>
		</transition>
		<transition id="id17">
			<source ref="id6"/>
			<target ref="id9"/>
			<label kind="guard" x="212" y="204">x&gt;=Tfr</label>
			<label kind="synchronisation" x="145" y="186">assistDone[zrToCommTo]!</label>
		</transition>
		<transition id="id18">
			<source ref="id9"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="-178" y="127">assistDone[idRescuing]!</label>
			<label kind="assignment" x="-136" y="153">setFRFree(id)</label>
			<nail x="8" y="178"/>
		</transition>
		<transition id="id19">
			<source ref="id8"/>
			<target ref="id5"/>
			<label kind="guard" x="204" y="-331">x&gt;=Tfr &amp;&amp; differentPerson()</label>
			<label kind="synchronisation" x="178" y="-314">assistDone[idRescuing]!</label>
			<label kind="assignment" x="178" y="-289">x=0</label>
			<nail x="654" y="-289"/>
		</transition>
		<transition id="id20">
			<source ref="id4"/>
			<target ref="id8"/>
			<label kind="guard" x="-645" y="-34">x&lt;Tfr</label>
			<label kind="synchronisation" x="-527" y="-314">assistDone[id]?</label>
			<label kind="assignment" x="-645" y="0">setWaiting(pos[id])</label>
			<nail x="-663" y="0"/>
			<nail x="-663" y="-289"/>
		</transition>
		<transition id="id21">
			<source ref="id4"/>
			<target ref="id3"/>
			<label kind="guard" x="-373" y="-153">x&lt;Tfr</label>
			<label kind="synchronisation" x="-323" y="-161">dead[idRescuing]?</label>
			<label kind="assignment" x="-323" y="-144">setFRFree(id)</label>
			<nail x="-391" y="-119"/>
			<nail x="-119" y="-119"/>
		</transition>
		<transition id="id22">
			<source ref="id5"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="127" y="110">dead[idRescuing]?</label>
			<label kind="assignment" x="144" y="127">setFRFree(id)</label>
			<nail x="289" y="102"/>
			<nail x="93" y="102"/>
		</transition>
		<transition id="id23">
			<source ref="id7"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="110" y="-68">starting?</label>
		</transition>
		<transition id="id24">
			<source ref="id5"/>
			<target ref="id6"/>
			<label kind="guard" x="663" y="68">x&gt;= waiting</label>
			<label kind="assignment" x="663" y="85">x=0</label>
		</transition>
		<transition id="id25">
			<source ref="id3"/>
			<target ref="id5"/>
			<label kind="synchronisation" x="178" y="0">assistDone[id]?</label>
			<label kind="assignment" x="161" y="17">x=0,setWaiting(pos[id])</label>
		</transition>
		<transition id="id26">
			<source ref="id3"/>
			<target ref="id3"/>
			<label kind="guard" x="-68" y="-161">!isNeedNear(pos[id])</label>
			<label kind="assignment" x="0" y="-144">move(id)</label>
			<nail x="-42" y="-119"/>
			<nail x="85" y="-119"/>
		</transition>
		<transition id="id27">
			<source ref="id3"/>
			<target ref="id4"/>
			<label kind="guard" x="-306" y="-25">isNeedNear(pos[id])</label>
			<label kind="assignment" x="-323" y="0">x=0,saveIdRescuing(pos[id])</label>
		</transition>
	</template>
	<template>
		<name>Civilian</name>
		<parameter>const id_zr id,int Tzr,int Pr</parameter>
		<declaration>clock x;
int waitingHelping;
int waitingFR;
int idFRtoCall; //id of the first responder the current civilian is calling

/**
 * @brief Checks if a position is valid within the grid bounds.
 *
 * @param x The x-coordinate to check.
 * @param y The y-coordinate to check.
 * @return true if the position is valid, false otherwise.
 */
bool isValid(int x, int y) {
    return x &gt;= 0 &amp;&amp; x &lt; GRID_W-1 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; GRID_H-1;
}


bool isFRAvailable(int id){;
    if(FRHelping[id-N_CIVILIANS] == DEF_POS)
        return true;
    else
        return false;
}


/**
 * @brief Checks if a position is near fire.
 *
 * @param x The x-coordinate to check.
 * @param y The y-coordinate to check.
 * @return true if the position is near fire, false otherwise.
 */
bool isFireNear(int x, int y) {
    const int DX[4] = {-1, 1, 0, 0}; // Up, Down
    const int DY[4] = {0, 0, -1, 1}; // Left, Right
    int i;

    for (i = 0; i &lt; 4; i++) {
        int nx = x + DX[i];
        int ny = y + DY[i];

        if (isValid(nx, ny) &amp;&amp; grid[ny][nx] == FIRE) {
            return true;
        }
    }
    return false;
}

/** Not sure if this function is necessary
 * @brief Checks if a zero responder is near the person to help.
 *
 * @param id the id of the zero responder.
 * @param x The x-coordinate to check.
 * @param y The y-coordinate to check.
 * @return true if the position is near the person to help, false otherwise.
 */
bool isNeedNear(int id) {

    if(abs_(helping[id].x - pos[id].x) == 1 || abs_(helping[id].y - pos[id].y) == 1) return true;

    return false;
}

/** Not sure if this function is necessary
 * @brief Checks if a zero responder is near the person to help.
 *
 * @param id the id of the zero responder.
 * @param x The x-coordinate to check.
 * @param y The y-coordinate to check.
 * @return true if the position is near the person to help, false otherwise.
 */
bool isFirstResponderNear(int id) {

    if(abs_(calling[id].x - pos[id].x) == 1 || abs_(calling[id].y - pos[id].y) == 1) return true;

    return false;
}


/**
 * @brief Moves a civilian to the nearest side of the grid if the next cell is not near the fire.
 *
 * This function attempts to move a civilian (identified by `id`) towards the nearest edge of the grid.
 * The movement is restricted to horizontal or vertical directions and ensures that the new position is
 * not near fire. The function checks each step to determine if the new position is valid.
 *
 * @param id The identifier of the civilian to be moved.
 */
void move(int id) { //todo improve this by making the civilian walk along the edge of the grid
    // Current position of the civilian
    int current_x = pos[id].x;
    int current_y = pos[id].y;
    int new_x;
    int new_y;

    // Determine the distances to each side of the grid
    int dist_top = current_y;
    int dist_bottom = GRID_H - 1 - current_y;
    int dist_left = current_x;
    int dist_right = GRID_W - 1 - current_x;

    // Determine the nearest side of the grid without using the min function
    int min_dist = dist_top;
    int direction = 0; // 0 for top, 1 for bottom, 2 for left, 3 for right

    if (dist_bottom &lt; min_dist) {
        min_dist = dist_bottom;
        direction = 1;
    }
    if (dist_left &lt; min_dist) {
        min_dist = dist_left;
        direction = 2;
    }
    if (dist_right &lt; min_dist) {
        min_dist = dist_right;
        direction = 3;
    }

    new_x = current_x;
    new_y = current_y;

    // Move in the direction of the nearest side
    if (direction == 0) {
        // Move up
        new_y = current_y - 1;
    } else if (direction == 1) {
        // Move down
        new_y = current_y + 1;
    } else if (direction == 2) {
        // Move left
        new_x = current_x - 1;
    } else if (direction == 3) {
        // Move right
        new_x = current_x + 1;
    }

    // Check if the new position is valid and not near fire
    if (new_x &gt;= 0 &amp;&amp; new_x &lt; GRID_W &amp;&amp; new_y &gt;= 0 &amp;&amp; new_y &lt; GRID_H) {
        if (grid[new_y][new_x] == EMPTY &amp;&amp; !isFireNear(new_x, new_y)) {
            pos[id].x = new_x;
            pos[id].y = new_y;
            grid[current_y][current_x] = EMPTY;
            grid[new_y][new_x] = SURVIVOR; //update the grid
        }
    }
    
}


/**
 * @brief Calculates the Manhattan distance of a civilian to the specified destination.
 *
 * This function calculates the Manhattan distance from the civilian's current position
 * to the specified destination (destx, desty).
 *
 * @param id The identifier of the civilian.
 * @param dest The position of the destination.
 * @return The Manhattan distance to the destination.
 */
int calculateDistance(int id, pos_t dest) {
    // Current position of the civilian
    pos_t current_pos;
    int distance;

    current_pos.x = pos[id].x;
    current_pos.y = pos[id].y;

    // Calculate Manhattan distance
    distance = abs(current_pos.x - dest.x) + abs(current_pos.y - dest.y);
    return distance;
}


/*
    checks if the entity is near the exit
*/
bool isExitNear(int x, int y) {
    // Directions for vertical and horizontal neighbors only
    int dx[4] = {-1, 1, 0, 0}; // Up, Down
    int dy[4] = {0, 0, -1, 1}; // Left, Right

    int i;
    for (i=0; i &lt; 4; i++) {
        int nx = x + dx[i];
        int ny = y + dy[i];

        // Check if the new coordinates are within the grid bounds
        if (nx &gt;= 0 &amp;&amp; ny &lt; GRID_H &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; GRID_W) {
            if (grid[ny][nx] == EXIT) {
                return true;
            }
        }
    }

    return false; // No exit found nearby
}

/**
 * @brief sets time it takes for a civilian to reach the person in need
 */
void setWaiting(){
   waitingHelping = abs(calculateDistance(id,helping[id]));
}

/**
 * @brief sets time it takes for a civilian to reach the first responder and the id of the fr to call
 */
void setWaitingfr() {
    pos_t f;
    f.x = calling[id].x;
    f.y = calling[id].y;
    waitingFR = abs(calculateDistance(id, f));
    idFRtoCall = abs(getIdFromPosFirstResponder(f));
}

/**
 * @brief sets the survivor's calling coordinates to default in both the calling and the helping table
 */
void setSurvFree(int id){
    calling[id] = DEF_POS;
    helping[id] = DEF_POS;
}

</declaration>
		<location id="id28" x="-493" y="-68">
			<name x="-544" y="-59">Initial</name>
			<committed/>
		</location>
		<location id="id29" x="-926" y="-68">
			<name x="-960" y="-102">InNeed</name>
			<label kind="invariant" x="-936" y="-51">x&lt;=Tv</label>
		</location>
		<location id="id30" x="-102" y="-68">
			<name x="-136" y="-102">Survivor</name>
			<label kind="invariant" x="-112" y="-51">x&lt;=Tv</label>
		</location>
		<location id="id31" x="-238" y="110">
			<name x="-263" y="76">Saved</name>
		</location>
		<location id="id32" x="238" y="-68">
			<name x="179" y="-102">ZeroResponder</name>
			<label kind="invariant" x="238" y="-59">x &lt;= waitingHelping + Tzr</label>
		</location>
		<location id="id33" x="-926" y="-229">
			<name x="-943" y="-263">Dead</name>
		</location>
		<location id="id34" x="-501" y="-161">
			<name x="-511" y="-195">Initializer</name>
		</location>
		<location id="id35" x="858" y="-467">
			<name x="756" y="-501">CallingFirstResponder</name>
			<label kind="invariant" x="799" y="-450">x &lt;= waitingFR</label>
		</location>
		<location id="id36" x="238" y="-255">
			<committed/>
		</location>
		<location id="id37" x="-102" y="-314">
			<committed/>
		</location>
		<location id="id38" x="25" y="-42">
			<committed/>
		</location>
		<branchpoint id="id39" x="68" y="-34"/>
		<branchpoint id="id40" x="-102" y="-365"/>
		<init ref="id34"/>
		<transition id="id41">
			<source ref="id38"/>
			<target ref="id39"/>
		</transition>
		<transition id="id42">
			<source ref="id30"/>
			<target ref="id38"/>
			<label kind="synchronisation" x="-76" y="-85">assist[id]?</label>
		</transition>
		<transition id="id43">
			<source ref="id37"/>
			<target ref="id40"/>
		</transition>
		<transition id="id44">
			<source ref="id30"/>
			<target ref="id37"/>
			<label kind="synchronisation" x="-306" y="-280">callFirstResponder[id]?</label>
		</transition>
		<transition id="id45">
			<source ref="id30"/>
			<target ref="id31"/>
			<label kind="guard" x="-153" y="17">x&gt;=Tv</label>
			<label kind="assignment" x="-246" y="34">grid[pos[id].y][pos[id].x] = EMPTY,n_safe=n_safe+1</label>
			<nail x="-161" y="51"/>
			<nail x="-238" y="76"/>
		</transition>
		<transition id="id46">
			<source ref="id39"/>
			<target ref="id32"/>
			<label kind="assignment" x="86" y="-51">x=0, setWaiting()</label>
			<label kind="probability" x="86" y="-34">Pr</label>
		</transition>
		<transition id="id47">
			<source ref="id39"/>
			<target ref="id30"/>
			<label kind="assignment" x="1" y="-4">setSurvFree(id)</label>
			<label kind="probability" x="1" y="13">100-Pr</label>
			<nail x="-17" y="25"/>
			<nail x="-110" y="0"/>
		</transition>
		<transition id="id48">
			<source ref="id40"/>
			<target ref="id30"/>
			<label kind="assignment" x="-408" y="-433">setSurvFree(id)</label>
			<label kind="probability" x="-170" y="-365">100-Pr</label>
			<nail x="-340" y="-416"/>
			<nail x="-433" y="-314"/>
			<nail x="-127" y="-187"/>
		</transition>
		<transition id="id49">
			<source ref="id40"/>
			<target ref="id35"/>
			<label kind="assignment" x="-84" y="-475">x=0, setWaitingfr()</label>
			<label kind="probability" x="-84" y="-458">Pr</label>
			<nail x="-102" y="-476"/>
		</transition>
		<transition id="id50">
			<source ref="id36"/>
			<target ref="id30"/>
			<label kind="assignment" x="-59" y="-289">grid[pos[id].y][pos[id].x] = SURVIVOR</label>
			<nail x="0" y="-255"/>
		</transition>
		<transition id="id51">
			<source ref="id32"/>
			<target ref="id36"/>
			<label kind="synchronisation" x="102" y="-161">dead[getIdFromPosCivilian(helping[id])]?</label>
			<label kind="assignment" x="255" y="-144">setSurvFree(id)</label>
			<nail x="238" y="-153"/>
		</transition>
		<transition id="id52">
			<source ref="id34"/>
			<target ref="id28"/>
			<label kind="synchronisation" x="-578" y="-153">starting?</label>
		</transition>
		<transition id="id53">
			<source ref="id32"/>
			<target ref="id31"/>
			<label kind="guard" x="255" y="0">x == waitingHelping + Tzr</label>
			<label kind="synchronisation" x="255" y="34">assistDone[getIdFromPosCivilian(helping[id])]!</label>
			<label kind="assignment" x="255" y="17">grid[pos[id].y][pos[id].x] = EMPTY,n_safe+=1</label>
			<nail x="246" y="110"/>
		</transition>
		<transition id="id54">
			<source ref="id30"/>
			<target ref="id28"/>
			<label kind="assignment" x="-391" y="-178">move(id)</label>
			<nail x="-153" y="-153"/>
			<nail x="-433" y="-153"/>
		</transition>
		<transition id="id55">
			<source ref="id29"/>
			<target ref="id31"/>
			<label kind="guard" x="-807" y="110">x&lt;Tv</label>
			<label kind="synchronisation" x="-799" y="68">assistDone[id]?</label>
			<label kind="assignment" x="-860" y="84">grid[pos[id].y][pos[id].x] = EMPTY, n_safe=n_safe+1</label>
			<label kind="comments" x="-766" y="119">when helped and time for helping finishes</label>
			<nail x="-902" y="110"/>
		</transition>
		<transition id="id56">
			<source ref="id29"/>
			<target ref="id33"/>
			<label kind="synchronisation" x="-918" y="-161">dead[id]!</label>
			<label kind="assignment" x="-918" y="-178">grid[pos[id].y][pos[id].x] = EMPTY</label>
		</transition>
		<transition id="id57">
			<source ref="id28"/>
			<target ref="id31"/>
			<label kind="guard" x="-586" y="8">isExitNear(pos[id].x, pos[id].y)</label>
			<label kind="assignment" x="-637" y="25">grid[pos[id].y][pos[id].x] = EMPTY,n_safe+=1</label>
			<nail x="-433" y="34"/>
		</transition>
		<transition id="id58">
			<source ref="id28"/>
			<target ref="id30"/>
			<label kind="guard" x="-442" y="-68">!isFireNear(pos[id].x, pos[id].y) &amp;&amp;
!isExitNear(pos[id].x, pos[id].y)</label>
			<label kind="assignment" x="-459" y="-93">grid[pos[id].y][pos[id].x] = SURVIVOR</label>
		</transition>
		<transition id="id59">
			<source ref="id28"/>
			<target ref="id29"/>
			<label kind="guard" x="-841" y="-110">isFireNear(pos[id].x, pos[id].y) &amp;&amp;
!isExitNear(pos[id].x, pos[id].y)</label>
			<label kind="assignment" x="-841" y="-59">grid[pos[id].y][pos[id].x] = NEED</label>
			<nail x="-595" y="-67"/>
		</transition>
		<transition id="id60">
			<source ref="id35"/>
			<target ref="id36"/>
			<label kind="guard" x="535" y="-425">x&lt; waitingFR</label>
			<label kind="synchronisation" x="374" y="-391">dead[getIdFromPosCivilian(helping[id])]?</label>
			<label kind="assignment" x="502" y="-409">setSurvFree(id)</label>
			<nail x="739" y="-373"/>
			<nail x="365" y="-373"/>
		</transition>
		<transition id="id61">
			<source ref="id35"/>
			<target ref="id31"/>
			<label kind="synchronisation" x="867" y="-289">assistDone[idFRtoCall]!</label>
			<label kind="assignment" x="867" y="-323">grid[pos[id].y][pos[id].x] = EMPTY,n_safe+=1,
n_safe+=1</label>
			<nail x="875" y="170"/>
			<nail x="-238" y="178"/>
		</transition>
	</template>
	<template>
		<name x="9" y="9">Drone</name>
		<parameter>const id_dr id,int Pf, int Nv</parameter>
		<declaration>/*
    Acronyms:
    PNA =&gt; person in need of assistance
*/

// local declarations
bool isMovingRight;
int distZR, distFR, nPNADetected, nSurvivorDetected, idFR = -1, idSurv = -1;
pos_t posPNA = DEF_POS, posSurv = DEF_POS, posFR = DEF_POS;
bool movingRight, movingUp; //determine if the drone is moving right or up 

/**
 * @brief Check if the detected survivor is available 
 * 
 *
 * @return bool confirming or not the availability of the survivor 
 */
bool isSurvAvailable(int id){
    if(calling[id] != DEF_POS || helping[id] != DEF_POS)
        return false;
    else
        return true; 
}

/**
 * @brief Check if the detected First Responder is available 
 * 
 *
 * @return bool confirming or not the availability of the First Responder 
 */
bool isFRAvailable(int id){;
    if(FRHelping[id-N_CIVILIANS] == DEF_POS)
        return true;
    else
        return false;
}

/**
 * @brief Checks if the PNA is being rescued by a zero responder or a First Responder 
 * Checks in the survivor helping table and in the first responder helping table if the PNA is being rescued 
 *
 * @return bool confirming or not if the PNA is being rescued or not  
 */
bool isPNABeingHelped(pos_t posPNA){
    int i,j;
    for(i=0;i&lt;N_CIVILIANS;i++){
       if(helping[i] == posPNA){
         return true;
        }    
    }
    for(j = 0; i &lt; N_FR; j++){
       if(FRHelping[j] == posPNA){
         return true;
        }   
    }
    return false;
}

/**
 * @brief Check all cells within the Manhattan distance Nv from the drone position
 * Registers first responders and survivors only if they are available 
 * Registers PNA only if its not being rescued already
 * @param id the drone id 
 */
    // 
void checkSurroundings(int id) {
    int dx, dy;
    int nx, ny; //new x and new y
    for (dx = -Nv; dx &lt;= Nv; dx++) {
        for (dy = -Nv; dy &lt;= Nv; dy++) {
            
            nx = posDrone[id].x + dx;
            ny = posDrone[id].y + dy;
            if (nx &gt;= 0 &amp;&amp; nx &lt; GRID_W &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; GRID_H) {
                pos_t newPos = {nx, ny};
                if (cell(newPos) == NEED) {
                    if (!isPNABeingHelped(newPos))
                        posPNA = newPos;
                } else if (cell(newPos) == SURVIVOR || cell(newPos) == CIVILIAN) {
                    if (isSurvAvailable(getIdFromPosCivilian(newPos))){
                        posSurv = newPos;
                        idSurv = getIdFromPosCivilian(posSurv);
                    }
                } else if (cell(newPos) == FIRST_RESPONDER) {
                    if (isFRAvailable(getIdFromPosFirstResponder(newPos))){
                        posFR = newPos;
                        idFR = getIdFromPosFirstResponder(posFR); 
                    }
                }
            }
        }
    }
}

/**
 * @brief Moves the drone in a cyclic pattern around its assigned portion of the grid
 * This function moves the drone in a cyclic patrol route,
 * covering its assigned portion of the grid efficiently.
 *
 * @param id the drone id
 */
void dronePatrol(int id) {
    // Determine the portion of the grid this drone will patrol
    int portionSize = GRID_W / N_DRONES;
    int startX = id * portionSize;
    int endX = startX + portionSize - 1;

    // Ensure the drone is within its assigned portion
    if (posDrone[id].x &lt; startX) {
        posDrone[id].x = startX;
    } else if (posDrone[id].x &gt; endX) {
        posDrone[id].x = endX;
    }

    // Check if the drone is at the right edge of its portion
    if (movingRight) {
        if (posDrone[id].x &lt; endX) {
            posDrone[id].x++;
        } else {
            // Reached the right edge, change direction and move vertically
            movingRight = false;
            if (movingUp) {
                if (posDrone[id].y &gt; 0) {
                    posDrone[id].y--;
                } else {
                    movingUp = false;
                    posDrone[id].y++;
                }
            } else {
                if (posDrone[id].y &lt; GRID_H - 1) {
                    posDrone[id].y++;
                } else {
                    movingUp = true;
                    posDrone[id].y--;
                }
            }
        }
    } else {
        // Check if the drone is at the left edge of its portion
        if (posDrone[id].x &gt; startX) {
            posDrone[id].x--;
        } else {
            // Reached the left edge, change direction and move vertically
            movingRight = true;
            if (movingUp) {
                if (posDrone[id].y &gt; 0) {
                    posDrone[id].y--;
                } else {
                    movingUp = false;
                    posDrone[id].y++;
                }
            } else {
                if (posDrone[id].y &lt; GRID_H - 1) {
                    posDrone[id].y++;
                } else {
                    movingUp = true;
                    posDrone[id].y--;
                }
            }
        }
    }

    checkSurroundings(id);
}





/**
 * @brief Check if a PNA has been detected during the surrouding check using the registered variables pos of each entity
 * 
 *
 * @return bool confirming or not the presence of a PNA
 */
bool isPNANearby(){
    if (posPNA == DEF_POS)
        return false;
return true;
}

/**
 * @brief Check if a Survivor has been detected during the surrouding check using the registered variables pos of each entity
 * 
 *
 * @return bool confirming or not the presence of a Survivor
 */
bool isSurvNearby(){
    if (posSurv == DEF_POS) 
        return false;
return true;
}

/**
 * @brief Check if a First Responder has been detected during the surrouding check using the registered variables pos of each entity
 * 
 *
 * @return bool confirming or not the presence of a First Responder
 */
bool isFRNearby(){
    if (posFR == DEF_POS)
        return false;
return true;
}

/**
 * @brief Register the survivor as busy in the calling table
 * 
 */
void setSurvBusyCalling(){
    calling[idSurv] = posFR;
    helping[idSurv] = posPNA;    
}

/**
 * @brief Register the survivor as busy in the helping table
 * 
 */
void setSurvBusyHelping(){
    helping[idSurv] = posPNA;  
}

/**
 * @brief Register the first responder as busy in the helping table
 * 
 */
void setFRBusyHelping(){
    FRHelping[idFR-N_CIVILIANS] = posPNA;
}


/**
 * @brief Resets all the data (pos and booleans) taken from the previous surrounding check in order to be ready for the next one
 * 
 */
void resetData(){
    
    posPNA = DEF_POS;
    posSurv = DEF_POS;
    posFR = DEF_POS;
    idFR = -1;
    idSurv = -1;
}


</declaration>
		<location id="id62" x="-527" y="-8">
			<name x="-561" y="-42">Initializer</name>
			<urgent/>
		</location>
		<location id="id63" x="170" y="-8">
			<name x="196" y="-17">Search_closest_responder</name>
			<committed/>
		</location>
		<location id="id64" x="-110" y="-8">
			<name x="-161" y="17">PNA_Detected</name>
			<committed/>
		</location>
		<location id="id65" x="-399" y="-8">
			<name x="-425" y="-42">Initial</name>
			<label kind="invariant" x="-409" y="9">global_time&lt;=Tv</label>
		</location>
		<location id="id66" x="-272" y="144">
			<label kind="invariant" x="-282" y="161">global_time&gt;=Tv</label>
		</location>
		<branchpoint id="id67" x="-246" y="-8"/>
		<init ref="id62"/>
		<transition id="id68">
			<source ref="id63"/>
			<target ref="id65"/>
			<label kind="guard" x="-323" y="246">!isFRNearby()</label>
			<label kind="synchronisation" x="-323" y="280">assist[idSurv]!</label>
			<label kind="assignment" x="-323" y="263">setSurvBusyHelping(),resetData()</label>
			<nail x="169" y="246"/>
			<nail x="-375" y="246"/>
		</transition>
		<transition id="id69">
			<source ref="id63"/>
			<target ref="id65"/>
			<label kind="guard" x="-365" y="-331">isFRNearby()</label>
			<label kind="synchronisation" x="-365" y="-314">callFirstResponder[idSurv]!</label>
			<label kind="assignment" x="-365" y="-297">setSurvBusyCalling(), setFRBusyHelping(), resetData()</label>
			<nail x="170" y="-272"/>
			<nail x="-391" y="-272"/>
		</transition>
		<transition id="id70">
			<source ref="id65"/>
			<target ref="id66"/>
			<label kind="guard" x="-391" y="85">global_time&gt;=Tv</label>
		</transition>
		<transition id="id71">
			<source ref="id67"/>
			<target ref="id65"/>
			<label kind="probability" x="-314" y="68">Pf</label>
			<nail x="-272" y="85"/>
		</transition>
		<transition id="id72">
			<source ref="id67"/>
			<target ref="id64"/>
			<label kind="probability" x="-221" y="-8">100-Pf</label>
		</transition>
		<transition id="id73">
			<source ref="id65"/>
			<target ref="id67"/>
			<label kind="guard" x="-357" y="-34">isPNANearby()</label>
		</transition>
		<transition id="id74">
			<source ref="id64"/>
			<target ref="id65"/>
			<label kind="guard" x="-348" y="-170">!isSurvNearby()</label>
			<label kind="assignment" x="-331" y="-187">resetData()</label>
			<nail x="-272" y="-144"/>
		</transition>
		<transition id="id75">
			<source ref="id65"/>
			<target ref="id65"/>
			<label kind="guard" x="-646" y="25">!isPNANearby()</label>
			<label kind="assignment" x="-680" y="42">dronePatrol(id)</label>
			<nail x="-544" y="51"/>
			<nail x="-484" y="111"/>
		</transition>
		<transition id="id76">
			<source ref="id64"/>
			<target ref="id63"/>
			<label kind="guard" x="-51" y="-42">isSurvNearby()</label>
		</transition>
		<transition id="id77">
			<source ref="id62"/>
			<target ref="id65"/>
		</transition>
	</template>
	<system>// Place template instantiations here.
// List one or more processes to be composed into a system.
// System Declaration

/* scenario 1 
C0 := Civilian(0, 1,20);
C1 := Civilian(1, 3,40);
C2 := Civilian(2, 2,30);
C3 := Civilian(3, 4,10);

F4 := FirstResponder(4, 2);
F5 := FirstResponder(5, 4);

D0 := Drone(0, 70,5);
D1 := Drone(1, 80,5);

system C0,C1,C2,C3, F4,F5, Initializer,D1,D0;
*/

/* scenario 2  */
C0 := Civilian(0, 1,80);
C1 := Civilian(1, 3,60);
C2 := Civilian(2, 2,90);
C3 := Civilian(3, 4,80);

F4 := FirstResponder(4, 2);
F5 := FirstResponder(5, 4);

D0 := Drone(0, 20,5);
D1 := Drone(1, 10,5);

system C0,C1,C2,C3, F4,F5, Initializer,D1,D0;


/* scenario 3 
C0 := Civilian(0, 2,20);
C1 := Civilian(1, 3,40);
C2 := Civilian(2, 4,50);
C3 := Civilian(3, 5,10);
C4 := Civilian(4, 2,50);
C5 := Civilian(5, 4,10);

F6 := FirstResponder(6, 5);
F7 := FirstResponder(7, 4);

D0 := Drone(0, 80,7);
D1 := Drone(1, 90,7);
D2 := Drone(2, 30,7);

system C0,C1,C2,C3,C4,C5, F6,F7, Initializer,D1,D0,D2;
*/</system>
	<queries>
		<option key="--statespace-consumption" value="2"/>
		<option key="--diagnostic" value="0"/>
		<query>
			<formula>Pr[&lt;=35] (&lt;&gt; (n_safe &gt;= (N_CIVILIANS * N_perc / 100)))</formula>
			<comment>This query is only for scenario 1-2 where Tscs = 35 s. It is possible for a percentage N% of all civilians to reach a safe state within time Tscs.</comment>
			<result outcome="success" type="quantity" value="0.921013 ± 0.0417609 (95% CI)" timestamp="2024-07-18 18:16:41 +0200">
				<option key="--statespace-consumption" value="2"/>
				<option key="--diagnostic" value="0"/>
				<details>0.921013 ± 0.0417609 (95% CI)</details>
				<plot title="Probability Density Distribution" xaxis="run duration in time" yaxis="probability density">
					<series title="density" type="b(1.328845)" color="0x0000ff" encoding="csv">17.725010299447632,0.008905716107343496
19.05385565943714,0.0
20.382701019426648,0.004452858053671748
21.711546379416152,0.0
23.04039173940566,0.004452858053671748
24.369237099395168,0.004452858053671748
25.698082459384672,0.013358574161015246
27.02692781937418,0.0
28.355773179363688,0.008905716107343496
29.684618539353195,0.49872010201123584
31.013463899342703,0.013358574161015246
32.34230925933221,0.026717148322030492
33.67115461932171,0.11577430939546546
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">30.55697612048077,0.0
30.55697612048077,0.49872010201123584
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1.3288, bucket count=13
Runs: 169 in total, 157 (92.899%) displayed, 12 (7.1006%) remaining
Span of displayed sample: [17.725, 35]
Mean estimate of displayed sample: 30.557 ± 0.39815 (95% CI)</comment>
				</plot>
				<plot title="Probability Density Confidence Intervals" xaxis="run duration in time" yaxis="probability density">
					<series title="upper limit" type="b(1.328845)" color="0xa0a0ff" encoding="csv">17.725010299447632,0.042093896196174034
19.05385565943714,0.021591188948230828
20.382701019426648,0.032525826830656294
21.711546379416152,0.021591188948230828
23.04039173940566,0.032525826830656294
24.369237099395168,0.032525826830656294
25.698082459384672,0.05099872759553871
27.02692781937418,0.021591188948230828
28.355773179363688,0.042093896196174034
29.684618539353195,0.7335224415507455
31.013463899342703,0.05099872759553871
32.34230925933221,0.07567040443330894
33.67115461932171,0.21723866740850498
					</series>
					<series title="lower limit" type="b(1.328845)" color="0x0000ff" encoding="csv">17.725010299447632,0.0014364179917631791
19.05385565943714,0.0
20.382701019426648,1.4979829381493156E-4
21.711546379416152,0.0
23.04039173940566,1.4979829381493156E-4
24.369237099395168,1.4979829381493156E-4
25.698082459384672,0.003675849842754643
27.02692781937418,0.0
28.355773179363688,0.0014364179917631791
29.684618539353195,0.5860990946903296
31.013463899342703,0.003675849842754643
32.34230925933221,0.013138432043190583
33.67115461932171,0.10302572741524632
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">30.55697612048077,0.0
30.55697612048077,0.551999851627986
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1.3288, bucket count=13
Runs: 169 in total, 157 (92.899%) displayed, 12 (7.1006%) remaining
Span of displayed sample: [17.725, 35]
Mean estimate of displayed sample: 30.557 ± 0.39815 (95% CI)</comment>
				</plot>
				<plot title="Probability Distribution" xaxis="run duration in time" yaxis="probability">
					<series title="probability" type="b(1.328845)" color="0x0000ff" encoding="csv">17.725010299447632,0.011834319526627219
19.05385565943714,0.0
20.382701019426648,0.005917159763313609
21.711546379416152,0.0
23.04039173940566,0.005917159763313609
24.369237099395168,0.005917159763313609
25.698082459384672,0.01775147928994083
27.02692781937418,0.0
28.355773179363688,0.011834319526627219
29.684618539353195,0.6627218934911243
31.013463899342703,0.01775147928994083
32.34230925933221,0.03550295857988166
33.67115461932171,0.15384615384615385
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">30.55697612048077,0.0
30.55697612048077,0.6627218934911243
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1.3288, bucket count=13
Runs: 169 in total, 157 (92.899%) displayed, 12 (7.1006%) remaining
Span of displayed sample: [17.725, 35]
Mean estimate of displayed sample: 30.557 ± 0.39815 (95% CI)</comment>
				</plot>
				<plot title="Probability Confidence Intervals" xaxis="run duration in time" yaxis="probability">
					<series title="upper limit" type="b(1.328845)" color="0xa0a0ff" encoding="csv">17.725010299447632,0.042093896196174034
19.05385565943714,0.021591188948230828
20.382701019426648,0.032525826830656294
21.711546379416152,0.021591188948230828
23.04039173940566,0.032525826830656294
24.369237099395168,0.032525826830656294
25.698082459384672,0.05099872759553871
27.02692781937418,0.021591188948230828
28.355773179363688,0.042093896196174034
29.684618539353195,0.7335224415507455
31.013463899342703,0.05099872759553871
32.34230925933221,0.07567040443330894
33.67115461932171,0.21723866740850498
					</series>
					<series title="lower limit" type="b(1.328845)" color="0x0000ff" encoding="csv">17.725010299447632,0.0014364179917631791
19.05385565943714,0.0
20.382701019426648,1.4979829381493156E-4
21.711546379416152,0.0
23.04039173940566,1.4979829381493156E-4
24.369237099395168,1.4979829381493156E-4
25.698082459384672,0.003675849842754643
27.02692781937418,0.0
28.355773179363688,0.0014364179917631791
29.684618539353195,0.5860990946903296
31.013463899342703,0.003675849842754643
32.34230925933221,0.013138432043190583
33.67115461932171,0.10302572741524632
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">30.55697612048077,0.0
30.55697612048077,0.7335224415507455
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1.3288, bucket count=13
Runs: 169 in total, 157 (92.899%) displayed, 12 (7.1006%) remaining
Span of displayed sample: [17.725, 35]
Mean estimate of displayed sample: 30.557 ± 0.39815 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Distribution" xaxis="run duration in time" yaxis="probability">
					<series title="cumulative" type="l" color="0x000000" encoding="csv">17.725010299447632,0.0
19.05385565943714,0.011834319526627219
20.382701019426648,0.011834319526627219
21.711546379416152,0.01775147928994083
23.04039173940566,0.01775147928994083
24.369237099395168,0.023668639053254437
25.698082459384672,0.029585798816568046
27.02692781937418,0.047337278106508875
28.355773179363688,0.047337278106508875
29.684618539353195,0.05917159763313609
31.013463899342703,0.7218934911242604
32.34230925933221,0.7396449704142012
33.67115461932171,0.7751479289940828
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">30.55697612048077,0.0
30.55697612048077,0.9289940828402367
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1.3288, bucket count=13
Runs: 169 in total, 157 (92.899%) displayed, 12 (7.1006%) remaining
Span of displayed sample: [17.725, 35]
Mean estimate of displayed sample: 30.557 ± 0.39815 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Confidence Intervals" xaxis="run duration in time" yaxis="probability">
					<series title="upper limit" type="k" color="0x0000dd" encoding="csv">17.725010299447632,0.021591188948230828
19.05385565943714,0.042093896196174034
20.382701019426648,0.042093896196174034
21.711546379416152,0.05099872759553871
23.04039173940566,0.05099872759553871
24.369237099395168,0.05948984381576862
25.698082459384672,0.0676900044954075
27.02692781937418,0.09114038017941548
28.355773179363688,0.09114038017941548
29.684618539353195,0.10612483660042892
31.013463899342703,0.7879558825685004
32.34230925933221,0.8040134043233735
33.67115461932171,0.8356994066538387
					</series>
					<series title="lower limit" type="k" color="0xdd0000" encoding="csv">17.725010299447632,0.0
19.05385565943714,0.0014364179917631791
20.382701019426648,0.0014364179917631791
21.711546379416152,0.003675849842754643
23.04039173940566,0.003675849842754643
24.369237099395168,0.0064857118842831935
25.698082459384672,0.009674813251688593
27.02692781937418,0.02065553546035489
28.355773179363688,0.02065553546035489
29.684618539353195,0.02873669909262892
31.013463899342703,0.6478701981467666
32.34230925933221,0.6666694532032976
33.67115461932171,0.7046878189316208
					</series>
					<series title="cumulative" type="l" color="0x000000" encoding="csv">17.725010299447632,0.0
19.05385565943714,0.011834319526627219
20.382701019426648,0.011834319526627219
21.711546379416152,0.01775147928994083
23.04039173940566,0.01775147928994083
24.369237099395168,0.023668639053254437
25.698082459384672,0.029585798816568046
27.02692781937418,0.047337278106508875
28.355773179363688,0.047337278106508875
29.684618539353195,0.05917159763313609
31.013463899342703,0.7218934911242604
32.34230925933221,0.7396449704142012
33.67115461932171,0.7751479289940828
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">30.55697612048077,0.0
30.55697612048077,0.9289940828402367
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1.3288, bucket count=13
Runs: 169 in total, 157 (92.899%) displayed, 12 (7.1006%) remaining
Span of displayed sample: [17.725, 35]
Mean estimate of displayed sample: 30.557 ± 0.39815 (95% CI)</comment>
				</plot>
				<plot title="Frequency Histogram" xaxis="run duration in time" yaxis="count">
					<series title="count" type="b(1.328845)" color="0x0000ff" encoding="csv">17.725010299447632,2.0
19.05385565943714,0.0
20.382701019426648,1.0
21.711546379416152,0.0
23.04039173940566,1.0
24.369237099395168,1.0
25.698082459384672,3.0
27.02692781937418,0.0
28.355773179363688,2.0
29.684618539353195,112.0
31.013463899342703,3.0
32.34230925933221,6.0
33.67115461932171,26.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">30.55697612048077,0.0
30.55697612048077,112.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1.3288, bucket count=13
Runs: 169 in total, 157 (92.899%) displayed, 12 (7.1006%) remaining
Span of displayed sample: [17.725, 35]
Mean estimate of displayed sample: 30.557 ± 0.39815 (95% CI)</comment>
				</plot>
			</result>
		</query>
		<query>
			<formula>Pr[&lt;=19] (&lt;&gt; (n_safe &gt;= (N_CIVILIANS * N_perc / 100)))</formula>
			<comment>This query is only for scenario 3, as we consider Tscs = 12 s.It is possible for a percentage N% of all civilians to reach a safe state within time Tscs.</comment>
			<option key="--statespace-consumption" value="2"/>
			<option key="--diagnostic" value="0"/>
			<result outcome="success" type="quantity" value="0.0306514 ± 0.0303669 (95% CI)" timestamp="2024-07-18 18:30:08 +0200">
				<option key="--statespace-consumption" value="2"/>
				<option key="--diagnostic" value="0"/>
				<details>0.0306514 ± 0.0303669 (95% CI)</details>
				<plot title="Probability Density Distribution" xaxis="run duration in time" yaxis="probability density">
					<series title="density" type="b(0.000000)" color="0x0000ff" encoding="csv">18.22584415759358,5.0602243004162875E13
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">18.22584415759358,0.0
18.22584415759358,5.0602243004162875E13
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=2.2204e-16, bucket count=1
Runs: 89 in total, 1 (1.1236%) displayed, 88 (98.876%) remaining
Displayed sample set: { 18.2258441575936 }</comment>
				</plot>
				<plot title="Probability Density Confidence Intervals" xaxis="run duration in time" yaxis="probability density">
					<series title="upper limit" type="b(0.000000)" color="0xa0a0ff" encoding="csv">18.22584415759358,0.061018304347082664
					</series>
					<series title="lower limit" type="b(0.000000)" color="0x0000ff" encoding="csv">18.22584415759358,2.844292949488092E-4
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">18.22584415759358,0.0
18.22584415759358,2.74802012720301E14
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=2.2204e-16, bucket count=1
Runs: 89 in total, 1 (1.1236%) displayed, 88 (98.876%) remaining
Displayed sample set: { 18.2258441575936 }</comment>
				</plot>
				<plot title="Probability Distribution" xaxis="run duration in time" yaxis="probability">
					<series title="probability" type="b(0.000000)" color="0x0000ff" encoding="csv">18.22584415759358,0.011235955056179775
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">18.22584415759358,0.0
18.22584415759358,0.011235955056179775
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=2.2204e-16, bucket count=1
Runs: 89 in total, 1 (1.1236%) displayed, 88 (98.876%) remaining
Displayed sample set: { 18.2258441575936 }</comment>
				</plot>
				<plot title="Probability Confidence Intervals" xaxis="run duration in time" yaxis="probability">
					<series title="upper limit" type="b(0.000000)" color="0xa0a0ff" encoding="csv">18.22584415759358,0.061018304347082664
					</series>
					<series title="lower limit" type="b(0.000000)" color="0x0000ff" encoding="csv">18.22584415759358,2.844292949488092E-4
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">18.22584415759358,0.0
18.22584415759358,0.061018304347082664
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=2.2204e-16, bucket count=1
Runs: 89 in total, 1 (1.1236%) displayed, 88 (98.876%) remaining
Displayed sample set: { 18.2258441575936 }</comment>
				</plot>
				<plot title="Cumulative Probability Distribution" xaxis="run duration in time" yaxis="probability">
					<series title="cumulative" type="l" color="0x000000" encoding="csv">18.22584415759358,0.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">18.22584415759358,0.0
18.22584415759358,0.011235955056179803
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=2.2204e-16, bucket count=1
Runs: 89 in total, 1 (1.1236%) displayed, 88 (98.876%) remaining
Displayed sample set: { 18.2258441575936 }</comment>
				</plot>
				<plot title="Cumulative Probability Confidence Intervals" xaxis="run duration in time" yaxis="probability">
					<series title="upper limit" type="k" color="0x0000dd" encoding="csv">18.22584415759358,0.04060085754963184
					</series>
					<series title="lower limit" type="k" color="0xdd0000" encoding="csv">18.22584415759358,0.0
					</series>
					<series title="cumulative" type="l" color="0x000000" encoding="csv">18.22584415759358,0.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">18.22584415759358,0.0
18.22584415759358,0.011235955056179803
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=2.2204e-16, bucket count=1
Runs: 89 in total, 1 (1.1236%) displayed, 88 (98.876%) remaining
Displayed sample set: { 18.2258441575936 }</comment>
				</plot>
				<plot title="Frequency Histogram" xaxis="run duration in time" yaxis="count">
					<series title="count" type="b(0.000000)" color="0x0000ff" encoding="csv">18.22584415759358,1.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">18.22584415759358,0.0
18.22584415759358,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=2.2204e-16, bucket count=1
Runs: 89 in total, 1 (1.1236%) displayed, 88 (98.876%) remaining
Displayed sample set: { 18.2258441575936 }</comment>
				</plot>
			</result>
		</query>
		<query>
			<formula>Pr[&lt;=10000] ([] (reached_Tscs() imply n_safe &gt;= (N_CIVILIANS * N_perc / 100)))

</formula>
			<comment>a percentage N% of all civilians is always guaranteed to reach a safe state within time Tscs</comment>
			<result outcome="success" type="quantity" value="0.220671 ± 0.0472652 (95% CI)" timestamp="2024-07-18 18:27:00 +0200">
				<option key="--statespace-consumption" value="2"/>
				<option key="--diagnostic" value="0"/>
				<details>0.220671 ± 0.0472652 (95% CI)</details>
			</result>
		</query>
		<query>
			<formula>E[&lt;=1000;10] (max: n_safe)</formula>
			<comment>Expected value for n_safe</comment>
			<result outcome="success" type="quantity" value="1.7 ± 0.34555 (95% CI)" timestamp="2024-07-18 18:31:09 +0200">
				<option key="--statespace-consumption" value="2"/>
				<option key="--diagnostic" value="0"/>
				<details>1.7 ± 0.34555 (95% CI)</details>
				<plot title="Probability Density Distribution" xaxis="max: n_safe" yaxis="probability density">
					<series title="density" type="b(1.000000)" color="0x0000ff" encoding="csv">1.0,0.3
2.0,0.7
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">1.7,0.0
1.7,0.7
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1, bucket count=2
Runs: 10 in total, 10 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [1, 2]
Mean estimate of displayed sample: 1.7 ± 0.3456 (95% CI)</comment>
				</plot>
				<plot title="Probability Distribution" xaxis="max: n_safe" yaxis="probability">
					<series title="probability" type="b(1.000000)" color="0x0000ff" encoding="csv">1.0,0.3
2.0,0.7
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">1.7,0.0
1.7,0.7
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1, bucket count=2
Runs: 10 in total, 10 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [1, 2]
Mean estimate of displayed sample: 1.7 ± 0.3456 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Distribution" xaxis="max: n_safe" yaxis="probability">
					<series title="cumulative" type="l" color="0x000000" encoding="csv">1.0,0.0
2.0,0.3
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">1.7,0.0
1.7,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1, bucket count=2
Runs: 10 in total, 10 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [1, 2]
Mean estimate of displayed sample: 1.7 ± 0.3456 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Confidence Intervals" xaxis="max: n_safe" yaxis="probability">
					<series title="upper limit" type="k" color="0x0000dd" encoding="csv">1.0,0.30849710781876083
2.0,0.6524528500599973
					</series>
					<series title="lower limit" type="k" color="0xdd0000" encoding="csv">1.0,0.0
2.0,0.06673951117773447
					</series>
					<series title="cumulative" type="l" color="0x000000" encoding="csv">1.0,0.0
2.0,0.3
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">1.7,0.0
1.7,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1, bucket count=2
Runs: 10 in total, 10 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [1, 2]
Mean estimate of displayed sample: 1.7 ± 0.3456 (95% CI)</comment>
				</plot>
				<plot title="Frequency Histogram" xaxis="max: n_safe" yaxis="count">
					<series title="count" type="b(1.000000)" color="0x0000ff" encoding="csv">1.0,3.0
2.0,7.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">1.7,0.0
1.7,7.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1, bucket count=2
Runs: 10 in total, 10 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [1, 2]
Mean estimate of displayed sample: 1.7 ± 0.3456 (95% CI)</comment>
				</plot>
			</result>
		</query>
	</queries>
</nta>
