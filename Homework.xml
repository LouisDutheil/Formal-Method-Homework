<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>// Place global declarations here.
const int EMPTY = 0;
const int FIRE = 1;
const int EXIT = 2;

const int DRONE = 3;                //drones must not be placed on the grid with other entities because they're supposed to be able to hover over human entities (should not take room in the table)
const int FIRST_RESPONDER = 4;

const int SURVIVOR = 5;
const int SAFE = 6;
const int NEED = 7;
const int CIVILIAN = 8;
const int N = 5;

/*********GLOBAL SYSTEM PARAMETERS *****************/


const int GRID_W = 10; //grid width
const int GRID_H = 10; //grid height
const int N_CIVILIANS = 5;  // Total number of civilians
const int N_DRONES = 3; //Total number of drones 
const int N_FR = 3; // Total number of first responders
const int Tv = 10; //time for the civilian to die close to a fire
const int Tfr = 10; //time to save a person
typedef int[0,N_CIVILIANS-1] id_zr;
typedef int[N_CIVILIANS,N_CIVILIANS+N_FR-1] id_fr;
typedef struct { int x, y; } pos_t;

/*********GLOBAL SYSTEM PARAMETERS ****************/


/*********GLOBAL VARIABLES*************************/

int grid[GRID_H][GRID_W];    // map considering role
// arrays used to put in relations ids with positions of entities (useful for drones too when contacting zero responders)
pos_t pos[N_CIVILIANS+N_FR];        // Array of coordinates of all civ+fr
// int posx[N_CIVILIANS+N_FR];       // Array of x coordinates of all civ+fr 
// int posy[N_CIVILIANS+N_FR];       // Array of y coordinates of all civ+fr
pos_t posDrone[N_DRONES];

//todo remove int xNeed[GRID_H][GRID_W];   // X coordinate for need requests, xNeed[1][2] set to 5 indicates that the civilian found at coordinates (y=1,x=2) is in charge of saving the person in need found at x = 5  
//todo remove int yNeed[GRID_H][GRID_W];   // Y coordinate for need requests, --same-- at y = value

pos_t helping[N_CIVILIANS]; // helping {{1, 5}, {-1, -1}} means that civilian with id 0 is helping person found at coordinate x = 1 and y = 5 while civilian with id 1 is free
pos_t calling[N_CIVILIANS]; // calling {{1, 5}, {-1, -1}} means that civilian with id 0 is calling first responder found at coordinate x = 1 and y = 5 while civilian with id 1 is free
pos_t FRHelping[N_FR];      // same principles for first responders  

/*********GLOBAL VARIABLES*************************/

/*** CHANNELS *************************************/

chan assist[N_CIVILIANS]; // Channel used by drones to request survivors to assist
chan callFIRST_RESPONDER[N_CIVILIANS]; //Channel used by drones to request survivors to call a first responder to help a person in need
chan assistDone[N_CIVILIANS]; // Channel used by civilian when they're saved by a zero responder/first responder
chan assistFromZR[N_FR];  // zero responders contact fr 
broadcast chan starting;    // channel used from the initializer
broadcast chan dead[N_CIVILIANS];  // each victim use it to advise in case of death

/*** CHANNELS *************************************/

/*** GLOBAL TYPES *********************************/



//...

/*** GLOBAL FUNCTIONS *************************************/

int cell(pos_t p) {
    return grid[p.x][p.y];
}

//Place the entity on the grid and register it in its respective array
void placeEntity(int id, int X, int Y, int entityType){
    grid[Y][X] = entityType;
    if (entityType == FIRST_RESPONDER || entityType == CIVILIAN){
        pos[id].x = X;
        pos[id].y = Y;
    }
    else if(entityType == DRONE){
        posDrone[id].x = X;
        posDrone[id].y = Y;
    }
    

}


void initializeGrid() {
    // Set all cells to EMPTY initially
    int i;
    for (i = 0; i &lt; GRID_W-1; i++) {
        int j;
        for (j = 0; j &lt; GRID_H-1; j++) {
            grid[i][j] = EMPTY;
        }
    }


    // Place exits in predefined positions
    grid[4][0] = EXIT;
    grid[5][0] = EXIT;
    grid[4][9] = EXIT;
    grid[5][9] = EXIT;
    //grid[GRID_W][1] = EXIT;

    //Place fire 
    grid[0][5] = FIRE;
    grid[0][6] = FIRE;
    grid[1][5] = FIRE;    
    grid[1][6] = FIRE;
    grid[2][5] = FIRE;
    grid[2][6] = FIRE;
    grid[2][4] = FIRE;
    grid[3][4] = FIRE;
    grid[3][5] = FIRE;

    //Place Civilians
    placeEntity(0, 1, 5, CIVILIAN);
    placeEntity(1, 3, 6, CIVILIAN);
    placeEntity(2, 5, 8, CIVILIAN);
    placeEntity(3, 8, 1, CIVILIAN);
    placeEntity(4, 6, 3, CIVILIAN);
    //command to initialize the civilian automata with its coordinates

    //Place First Responders
    placeEntity(5, 1, 2, FIRST_RESPONDER);
    placeEntity(6, 6, 4, FIRST_RESPONDER);
    placeEntity(7, 8, 7, FIRST_RESPONDER);
   
    
    //command to initialize the FIRST_RESPONDER automata with its coordinates

    //Place Drones
    placeEntity(0, 1, 0, DRONE);
    placeEntity(0, 4, 0, DRONE);
    placeEntity(0, 7, 0, DRONE);
    //command to initialize the drone automata with its coordinates

  
    
}


int abs_(int x) {
  if (x &lt; 0) {
    return -x;
  }
  return x;
}

/**
 * @brief Given coordinates x,y search in pos array to get the id of the civilian
 *
 * @param x The x-coordinate.
 * @param y The y-coordinate.
 * @return id of the specific entity.
 */
int getIdFromPosCivilian(pos_t posCiv){
   int i;
   for(i=0;i&lt;N_CIVILIANS;i++){
       if(pos[i].x== posCiv.x &amp;&amp; pos[i].y== posCiv.y){
         return i;
        }    
    }
    return -1;
}

/**
 * @brief Given coordinates x,y search in pos array to get the id of the first responder
 *
 * @param x The x-coordinate.
 * @param y The y-coordinate.
 * @return id of the specific entity.
 */
int getIdFromPosFirstResponder(pos_t posFR){
    int i;
    for(i=N_CIVILIANS;i&lt;N_CIVILIANS+N_FR;i++){
       if(pos[i].x== posFR.x &amp;&amp; pos[i].y== posFR.y){
         return i;
        }    
    }
    return -1;
}



</declaration>
	<template>
		<name>Initializer</name>
		<location id="id0" x="0" y="0">
			<name x="-10" y="-34">Initial</name>
			<urgent/>
		</location>
		<location id="id1" x="0" y="119">
		</location>
		<init ref="id0"/>
		<transition id="id2">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="0" y="42">starting!</label>
			<label kind="assignment" x="0" y="59">initializeGrid()</label>
		</transition>
	</template>
	<template>
		<name>FirstResponder</name>
		<parameter>const id_fr id</parameter>
		<declaration>clock x;
int Tfr;

void setTfr(){
    Tfr= 5; 
}


int idRescuing; // id person we're rescuing
int waiting; // distance from person in need when zr called
int zrToCommTo; // id zr to contact when finishing Tfr

/**
 * @brief Checks if a position is valid within the grid bounds.
 *
 * @param x The x-coordinate to check.
 * @param y The y-coordinate to check.
 * @return true if the position is valid, false otherwise.
 */
bool isValid(int x, int y) {
    if(x &gt;= 0 &amp;&amp; x &lt; GRID_W-1 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; GRID_H-1){
        return true;
    }
    return false;
}

/**
 * @brief Checks if a position is near fire.
 *
 * @param x The x-coordinate to check.
 * @param y The y-coordinate to check.
 * @return true if the position is near fire, false otherwise.
 */
bool isFireNear(int x, int y) {
    const int DX[4] = {-1, 1, 0, 0}; // Up, Down
    const int DY[4] = {0, 0, -1, 1}; // Left, Right
    int i;

    for (i = 0; i &lt; 4; i++) {
        int nx = x + DX[i];
        int ny = y + DY[i];

        if (isValid(nx, ny) &amp;&amp; grid[ny][nx] == FIRE) {
            return true;
        }
    }
    return false;
}
/**
 * @brief Checks if a position is near to a person in need.
 *
 * @param x The x-coordinate to check.
 * @param y The y-coordinate to check.
 * @return true if the position is near a person in need, false otherwise.
 */
bool isNeedNear(pos_t posNeed) {
    const int DX[4] = {-1, 1, 0, 0}; // Up, Down
    const int DY[4] = {0, 0, -1, 1}; // Left, Right
    int i;

    for (i = 0; i &lt; 4; i++) {
        int nx = posNeed.x + DX[i];
        int ny = posNeed.y + DY[i];

        if (isValid(nx, ny) &amp;&amp; grid[ny][nx] == NEED) {
            return true;
        }
    }
    return false;
}

void saveIdRescuing(pos_t posResc){
  const int DX[4] = {-1, 1, 0, 0}; // Up, Down
    const int DY[4] = {0, 0, -1, 1}; // Left, Right
    int i;

    for (i = 0; i &lt; 4; i++) {
        int nx = posResc.x + DX[i];
        int ny = posResc.y + DY[i];
        pos_t newPos = {nx, ny};
        if (isValid(nx, ny) &amp;&amp; grid[ny][nx] == NEED) {
            idRescuing = getIdFromPosCivilian(newPos);
        }
    }
}

/**
 * @brief Moves a first responder to the nearest side of the grid if the next cell is not near the fire.
 *
 * This function attempts to move a first responder (identified by `id`) towards the nearest edge of the grid.
 * The movement is restricted to horizontal or vertical directions and ensures that the new position is
 * not near fire. The function checks each step to determine if the new position is valid.
 *
 * @param id The identifier of the civilian to be moved.
 */
void move(int id) {
    // Current position of the civilian
    int current_x = pos[id].x;
    int current_y = pos[id].y;
    int new_x;
    int new_y;

    // Determine the distances to each side of the grid
    int dist_top = current_y;
    int dist_bottom = GRID_H - 1 - current_y;
    int dist_left = current_x;
    int dist_right = GRID_W - 1 - current_x;

    // Determine the nearest side of the grid without using the min function
    int min_dist = dist_top;
    int direction = 0; // 0 for top, 1 for bottom, 2 for left, 3 for right

    if (dist_bottom &lt; min_dist) {
        min_dist = dist_bottom;
        direction = 1;
    }
    if (dist_left &lt; min_dist) {
        min_dist = dist_left;
        direction = 2;
    }
    if (dist_right &lt; min_dist) {
        min_dist = dist_right;
        direction = 3;
    }

    new_x = current_x;
    new_y = current_y;

    // Move in the direction of the nearest side
    if (direction == 0) {
        // Move up
        new_y = current_y - 1;
    } else if (direction == 1) {
        // Move down
        new_y = current_y + 1;
    } else if (direction == 2) {
        // Move left
        new_x = current_x - 1;
    } else if (direction == 3) {
        // Move right
        new_x = current_x + 1;
    }

    // Check if the new position is valid and not near fire
    if (new_x &gt;= 0 &amp;&amp; new_x &lt; GRID_W &amp;&amp; new_y &gt;= 0 &amp;&amp; new_y &lt; GRID_H) {
        if (grid[new_y][new_x] == EMPTY &amp;&amp; !isFireNear(new_x, new_y)) {
            pos[id].x = new_x;
            pos[id].y = new_y;
            grid[current_y][current_x] = EMPTY;
            grid[new_y][new_x] = FIRST_RESPONDER; //update the grid
        }
    }
}


/**
 * @brief Calculates the distance of a fr to the specified destination avoiding cells near fire.
 *
 * This function calculates the shortest distance from the fr's current position
 * to the specified destination (destx, desty) while avoiding cells near fire.
 *
 * @param id The identifier of the civilian.
 * @param destx The x-coordinate of the destination.
 * @param desty The y-coordinate of the destination.
 * @return The distance to the destination, or -1 if the destination is not reachable.
 */
int calculateDistance(int id, pos_t dest) {
    // Current position of the civilian
    pos_t current_pos = pos[id];

    // Directions for vertical and horizontal neighbors only
    const int DX[4] = {-1, 1, 0, 0}; // Up, Down
    const int DY[4] = {0, 0, -1, 1}; // Left, Right

    // Queue for BFS (simulated using arrays)
    int qx[GRID_W * GRID_H];
    int qy[GRID_W * GRID_H];
    int dist[GRID_W * GRID_H];
    int front = 0;
    int rear = 0;

    // Arrays to track visited cells
    bool visited[GRID_H][GRID_W];
    visited[GRID_H][GRID_W]=false;
    // Check if the current position is already the destination
    if (current_pos == dest) {
        return 0;
    }

    // Initialize BFS
    qx[rear] = current_pos.x;
    qy[rear] = current_pos.y;
    dist[rear] = 0;
    rear++;
    visited[current_pos.y][current_pos.x] = true;

    // BFS loop
    while (front &lt; rear) {
        int curr_x = qx[front];
        int curr_y = qy[front];
        int curr_dist = dist[front];
        int i;

        front++;

        for (i = 0; i &lt; 4; i++) {
            int new_x = curr_x + DX[i];
            int new_y = curr_y + DY[i];

            if (isValid(new_x, new_y) &amp;&amp; !visited[new_y][new_x] &amp;&amp; grid[new_y][new_x] == EMPTY /*&amp;&amp; !isFireNear(new_x, new_y)*/) {
                if (new_x == dest.x &amp;&amp; new_y == dest.y) {
                    return curr_dist + 1;
                }

                qx[rear] = new_x;
                qy[rear] = new_y;
                dist[rear] = curr_dist + 1;
                rear++;
                visited[new_y][new_x] = true;
            }
        }
    }

    // If we exhaust the queue without finding the destination
    return -1;
}




void setWaiting(pos_t posFR){
   pos_t pos_rescue;
   int i;
   
   for(i=0;i&lt;N_CIVILIANS;i++){
      if(calling[i] == posFR){
            pos_rescue = helping[i];
            zrToCommTo = i;     
     }
    } 
   waiting = calculateDistance(id,pos_rescue);
}</declaration>
		<location id="id3" x="8" y="0">
			<name x="-2" y="-34">Initial</name>
			<urgent/>
		</location>
		<location id="id4" x="-416" y="0">
			<name x="-426" y="-34">Rescue_person</name>
			<label kind="invariant" x="-426" y="17">x&lt;=Tfr</label>
		</location>
		<location id="id5" x="654" y="0">
			<name x="644" y="-34">Called</name>
			<label kind="invariant" x="644" y="17">x&lt;=waiting</label>
		</location>
		<location id="id6" x="654" y="178">
			<label kind="invariant" x="644" y="195">x&lt;=Tfr</label>
		</location>
		<location id="id7" x="229" y="-93">
			<name x="219" y="-127">Initializer</name>
			<urgent/>
		</location>
		<init ref="id7"/>
		<transition id="id8">
			<source ref="id5"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="42" y="110">dead[getIdFromPosCivilian(helping[zrToCommTo])]?</label>
			<nail x="289" y="102"/>
			<nail x="93" y="102"/>
		</transition>
		<transition id="id9">
			<source ref="id7"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="76" y="-76">starting?</label>
			<label kind="assignment" x="110" y="-51">setTfr()</label>
		</transition>
		<transition id="id10">
			<source ref="id6"/>
			<target ref="id3"/>
			<label kind="guard" x="25" y="195">x&gt; Tfr</label>
			<label kind="synchronisation" x="17" y="212">assistDone[zrToCommTo]!</label>
			<label kind="assignment" x="26" y="178">x=0</label>
			<nail x="8" y="178"/>
		</transition>
		<transition id="id11">
			<source ref="id5"/>
			<target ref="id6"/>
			<label kind="guard" x="663" y="68">x&gt; waiting</label>
			<label kind="assignment" x="663" y="85">x=0</label>
		</transition>
		<transition id="id12">
			<source ref="id3"/>
			<target ref="id5"/>
			<label kind="synchronisation" x="59" y="0">assistFromZR[id-N_CIVILIANS]?</label>
			<label kind="assignment" x="42" y="17">x=0,setWaiting(pos[id])</label>
		</transition>
		<transition id="id13">
			<source ref="id3"/>
			<target ref="id3"/>
			<label kind="guard" x="-68" y="-161">!isNeedNear(pos[id])</label>
			<label kind="assignment" x="0" y="-144">move(id)</label>
			<nail x="-42" y="-119"/>
			<nail x="85" y="-119"/>
		</transition>
		<transition id="id14">
			<source ref="id4"/>
			<target ref="id3"/>
			<label kind="assignment" x="-263" y="119">move(id),x=0</label>
			<nail x="-221" y="119"/>
		</transition>
		<transition id="id15">
			<source ref="id3"/>
			<target ref="id4"/>
			<label kind="guard" x="-297" y="-25">isNeedNear(pos[id])</label>
			<label kind="synchronisation" x="-263" y="-42">assistDone[idRescuing]!</label>
			<label kind="assignment" x="-348" y="0">x=0,saveIdRescuing(pos[id])</label>
			<nail x="-254" y="0"/>
			<nail x="-254" y="0"/>
		</transition>
	</template>
	<template>
		<name>Civilian</name>
		<parameter>const id_zr id</parameter>
		<declaration>clock x;
int Tzr;
int waitingHelping;
int waitingFR;

/**
 * @brief set the time it takes for a specific survivor to help a person in need once reached
 */
void setTzr(){
    Tzr= 7; 
}


/**
 * @brief Checks if a position is valid within the grid bounds.
 *
 * @param x The x-coordinate to check.
 * @param y The y-coordinate to check.
 * @return true if the position is valid, false otherwise.
 */
bool isValid(int x, int y) {
    return x &gt;= 0 &amp;&amp; x &lt; GRID_W-1 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; GRID_H-1;
}

/**
 * @brief Checks if a position is near fire.
 *
 * @param x The x-coordinate to check.
 * @param y The y-coordinate to check.
 * @return true if the position is near fire, false otherwise.
 */
bool isFireNear(int x, int y) {
    const int DX[4] = {-1, 1, 0, 0}; // Up, Down
    const int DY[4] = {0, 0, -1, 1}; // Left, Right
    int i;

    for (i = 0; i &lt; 4; i++) {
        int nx = x + DX[i];
        int ny = y + DY[i];

        if (isValid(nx, ny) &amp;&amp; grid[ny][nx] == FIRE) {
            return true;
        }
    }
    return false;
}

/** Not sure if this function is necessary
 * @brief Checks if a zero responder is near the person to help.
 *
 * @param id the id of the zero responder.
 * @param x The x-coordinate to check.
 * @param y The y-coordinate to check.
 * @return true if the position is near the person to help, false otherwise.
 */
bool isNeedNear(int id) {

    if(abs_(helping[id].x - pos[id].x) == 1 || abs_(helping[id].y - pos[id].y) == 1) return true;

    return false;
}

/** Not sure if this function is necessary
 * @brief Checks if a zero responder is near the person to help.
 *
 * @param id the id of the zero responder.
 * @param x The x-coordinate to check.
 * @param y The y-coordinate to check.
 * @return true if the position is near the person to help, false otherwise.
 */
bool isFirstResponderNear(int id) {

    if(abs_(calling[id].x - pos[id].x) == 1 || abs_(calling[id].y - pos[id].y) == 1) return true;

    return false;
}

/**
 * @brief Moves a civilian to the nearest side of the grid if the next cell is not near the fire.
 *
 * This function attempts to move a civilian (identified by `id`) towards the nearest edge of the grid.
 * The movement is restricted to horizontal or vertical directions and ensures that the new position is
 * not near fire. The function checks each step to determine if the new position is valid.
 *
 * @param id The identifier of the civilian to be moved.
 */
void move(int id) {
    // Current position of the civilian
    int current_x = pos[id].x;
    int current_y = pos[id].y;
    int new_x;
    int new_y;

    // Determine the distances to each side of the grid
    int dist_top = current_y;
    int dist_bottom = GRID_H - 1 - current_y;
    int dist_left = current_x;
    int dist_right = GRID_W - 1 - current_x;

    // Determine the nearest side of the grid without using the min function
    int min_dist = dist_top;
    int direction = 0; // 0 for top, 1 for bottom, 2 for left, 3 for right

    if (dist_bottom &lt; min_dist) {
        min_dist = dist_bottom;
        direction = 1;
    }
    if (dist_left &lt; min_dist) {
        min_dist = dist_left;
        direction = 2;
    }
    if (dist_right &lt; min_dist) {
        min_dist = dist_right;
        direction = 3;
    }

    new_x = current_x;
    new_y = current_y;

    // Move in the direction of the nearest side
    if (direction == 0) {
        // Move up
        new_y = current_y - 1;
    } else if (direction == 1) {
        // Move down
        new_y = current_y + 1;
    } else if (direction == 2) {
        // Move left
        new_x = current_x - 1;
    } else if (direction == 3) {
        // Move right
        new_x = current_x + 1;
    }

    // Check if the new position is valid and not near fire
    if (new_x &gt;= 0 &amp;&amp; new_x &lt; GRID_W &amp;&amp; new_y &gt;= 0 &amp;&amp; new_y &lt; GRID_H) {
        if (grid[new_y][new_x] == EMPTY &amp;&amp; !isFireNear(new_x, new_y)) {
            pos[id].x = new_x;
            pos[id].y = new_y;
            grid[current_y][current_x] = EMPTY;
            grid[new_y][new_x] = SURVIVOR; //update the grid
        }
    }
}

/**
 * @brief Calculates the distance of a civilian to the specified destination avoiding cells near fire.
 *
 * This function calculates the shortest distance from the civilian's current position
 * to the specified destination (destx, desty) while avoiding cells near fire.
 *
 * @param id The identifier of the civilian.
 * @param destx The x-coordinate of the destination.
 * @param desty The y-coordinate of the destination.
 * @return The distance to the destination, or -1 if the destination is not reachable.
 */
int calculateDistance(int id, pos_t dest) {
    // Current position of the civilian
    pos_t current_pos = pos[id];

    // Directions for vertical and horizontal neighbors only
    const int DX[4] = {-1, 1, 0, 0}; // Up, Down
    const int DY[4] = {0, 0, -1, 1}; // Left, Right

    // Queue for BFS (simulated using arrays)
    int qx[GRID_W * GRID_H];
    int qy[GRID_W * GRID_H];
    int dist[GRID_W * GRID_H];
    int front = 0;
    int rear = 0;

    // Arrays to track visited cells
    bool visited[GRID_H][GRID_W];
    visited[GRID_H][GRID_W]=false;
    // Check if the current position is already the destination
    if (current_pos == dest) {
        return 0;
    }

    // Initialize BFS
    qx[rear] = current_pos.x;
    qy[rear] = current_pos.y;
    dist[rear] = 0;
    rear++;
    visited[current_pos.y][current_pos.x] = true;

    // BFS loop
    while (front &lt; rear) {
        int curr_x = qx[front];
        int curr_y = qy[front];
        int curr_dist = dist[front];
        int i;

        front++;

        for (i = 0; i &lt; 4; i++) {
            int new_x = curr_x + DX[i];
            int new_y = curr_y + DY[i];

            if (isValid(new_x, new_y) &amp;&amp; !visited[new_y][new_x] &amp;&amp; grid[new_y][new_x] == EMPTY /*&amp;&amp; !isFireNear(new_x, new_y)*/) {
                if (new_x == dest.x &amp;&amp; new_y == dest.y) {
                    return curr_dist + 1;
                }

                qx[rear] = new_x;
                qy[rear] = new_y;
                dist[rear] = curr_dist + 1;
                rear++;
                visited[new_y][new_x] = true;
            }
        }
    }

    // If we exhaust the queue without finding the destination
    return -1;
}



/*
    checks if the entity is near the exit
*/
bool isExitNear(int x, int y) {
    // Directions for vertical and horizontal neighbors only
    int dx[4] = {-1, 1, 0, 0}; // Up, Down
    int dy[4] = {0, 0, -1, 1}; // Left, Right

    int i;
    for (i=0; i &lt; 4; i++) {
        int nx = x + dx[i];
        int ny = y + dy[i];

        // Check if the new coordinates are within the grid bounds
        if (nx &gt;= 0 &amp;&amp; ny &lt; GRID_H &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; GRID_W) {
            if (grid[ny][nx] == EXIT) {
                return true;
            }
        }
    }

    return false; // No exit found nearby
}

/**
 * @brief sets time it takes for a civilian to reach the person in need
 */
void setWaiting(){
   waitingHelping = calculateDistance(id,helping[id]);
}

/**
 * @brief sets time it takes for a civilian to reach the first responder
 */
void setWaitingfr(){
   waitingFR = calculateDistance(id,calling[id]);
}



</declaration>
		<location id="id16" x="-493" y="-68">
			<name x="-544" y="-59">Initial</name>
			<urgent/>
		</location>
		<location id="id17" x="-926" y="-68">
			<name x="-960" y="-102">InNeed</name>
			<label kind="invariant" x="-936" y="-51">x&lt;=Tv</label>
		</location>
		<location id="id18" x="-102" y="-68">
			<name x="-136" y="-102">Survivor</name>
		</location>
		<location id="id19" x="-238" y="110">
			<name x="-263" y="76">Saved</name>
		</location>
		<location id="id20" x="238" y="-68">
			<name x="179" y="-102">ZeroResponder</name>
			<label kind="invariant" x="195" y="-59">x &lt; waitingHelping</label>
		</location>
		<location id="id21" x="850" y="-459">
			<name x="748" y="-493">CallingFirstResponder</name>
			<label kind="invariant" x="791" y="-442">x &lt; waitingFR</label>
		</location>
		<location id="id22" x="-926" y="-229">
			<name x="-943" y="-263">Dead</name>
		</location>
		<location id="id23" x="238" y="127">
			<label kind="invariant" x="255" y="118">x &lt;= Tzr</label>
		</location>
		<location id="id24" x="850" y="-119">
			<name x="867" y="-144">ReachedFIRST_RESPONDER</name>
			<label kind="invariant" x="816" y="-102">x&lt;=waitingHelping</label>
		</location>
		<location id="id25" x="850" y="255">
			<name x="858" y="222">ReachedNeed</name>
		</location>
		<location id="id26" x="-501" y="-161">
			<name x="-511" y="-195">Initializer</name>
			<urgent/>
		</location>
		<location id="id27" x="851" y="51">
			<name x="876" y="42">IntermediateState2ndChannel</name>
			<label kind="comments" x="875" y="102">Intermediate Location put in committed so that the time doesnt run
Needed to have a 2nd edge for the 2nd channel</label>
			<committed/>
		</location>
		<init ref="id26"/>
		<transition id="id28">
			<source ref="id27"/>
			<target ref="id25"/>
			<label kind="synchronisation" x="901" y="76">assistDone[getIdFromPosCivilian(helping[id])]!</label>
		</transition>
		<transition id="id29">
			<source ref="id24"/>
			<target ref="id18"/>
			<label kind="synchronisation" x="127" y="-306">dead[getIdFromPosCivilian(helping[id])]?</label>
			<nail x="612" y="-314"/>
			<nail x="68" y="-314"/>
		</transition>
		<transition id="id30">
			<source ref="id21"/>
			<target ref="id18"/>
			<label kind="synchronisation" x="144" y="-382">dead[getIdFromPosCivilian(helping[id])]?</label>
			<nail x="629" y="-357"/>
			<nail x="59" y="-357"/>
		</transition>
		<transition id="id31">
			<source ref="id20"/>
			<target ref="id18"/>
			<label kind="synchronisation" x="-59" y="-212">dead[getIdFromPosCivilian(helping[id])]?</label>
			<nail x="76" y="-187"/>
		</transition>
		<transition id="id32">
			<source ref="id26"/>
			<target ref="id16"/>
			<label kind="synchronisation" x="-578" y="-153">starting?</label>
			<label kind="assignment" x="-569" y="-136">setTzr()</label>
		</transition>
		<transition id="id33">
			<source ref="id25"/>
			<target ref="id19"/>
			<label kind="synchronisation" x="127" y="238">assistDone[id]?</label>
			<label kind="assignment" x="127" y="263">x=0,
grid[pos[id].y][pos[id].x] = EMPTY</label>
			<label kind="comments" x="977" y="204">What if the person in need dies 
before the first responder can help him? 
In that case this zero responder
 would be stuck.
I would add a signal from the dead person that
notifies everyone about the death</label>
			<nail x="493" y="263"/>
			<nail x="221" y="263"/>
			<nail x="-153" y="263"/>
		</transition>
		<transition id="id34">
			<source ref="id24"/>
			<target ref="id27"/>
			<label kind="guard" x="867" y="-51">x&gt;=waitingHelping</label>
			<label kind="synchronisation" x="867" y="-17">assistFromZR[getIdFromPosFirstResponder(calling[id])-N_CIVILIANS]!</label>
			<label kind="assignment" x="867" y="-34">x=0</label>
			<label kind="comments" x="909" y="8">doesn't work with 2 channels contemporary on the same edge</label>
		</transition>
		<transition id="id35">
			<source ref="id21"/>
			<target ref="id24"/>
			<label kind="guard" x="858" y="-357">x &gt;= waitingFR</label>
			<label kind="assignment" x="858" y="-340">x=0, setWaiting()</label>
		</transition>
		<transition id="id36">
			<source ref="id23"/>
			<target ref="id19"/>
			<label kind="guard" x="-110" y="51">x&gt;=Tzr</label>
			<label kind="assignment" x="-110" y="68">x = 0,
grid[pos[id].y][pos[id].x] = EMPTY</label>
		</transition>
		<transition id="id37">
			<source ref="id20"/>
			<target ref="id23"/>
			<label kind="guard" x="238" y="-34">x&gt;= waitingHelping</label>
			<label kind="synchronisation" x="246" y="0">assistDone[getIdFromPosCivilian(helping[id])]!</label>
			<label kind="assignment" x="246" y="-17">x=0</label>
		</transition>
		<transition id="id38">
			<source ref="id18"/>
			<target ref="id16"/>
			<label kind="assignment" x="-323" y="-178">move(id)</label>
			<nail x="-153" y="-153"/>
			<nail x="-433" y="-153"/>
		</transition>
		<transition id="id39">
			<source ref="id17"/>
			<target ref="id19"/>
			<label kind="synchronisation" x="-884" y="59">assistDone[id]?</label>
			<label kind="assignment" x="-884" y="76">grid[pos[id].y][pos[id].x] = EMPTY</label>
			<label kind="comments" x="-790" y="111">when helped and time for helping finishes</label>
			<nail x="-926" y="102"/>
			<nail x="-391" y="102"/>
		</transition>
		<transition id="id40">
			<source ref="id17"/>
			<target ref="id22"/>
			<label kind="guard" x="-918" y="-195">x &gt; Tv</label>
			<label kind="synchronisation" x="-918" y="-161">dead[id]!</label>
			<label kind="assignment" x="-918" y="-178">grid[pos[id].y][pos[id].x] = EMPTY</label>
		</transition>
		<transition id="id41">
			<source ref="id18"/>
			<target ref="id21"/>
			<label kind="synchronisation" x="59" y="-493">callFIRST_RESPONDER[id]?</label>
			<label kind="assignment" x="76" y="-510">x:=0, setWaitingfr()</label>
			<nail x="-93" y="-467"/>
		</transition>
		<transition id="id42">
			<source ref="id18"/>
			<target ref="id20"/>
			<label kind="synchronisation" x="17" y="-93">assist[id]?</label>
			<label kind="assignment" x="0" y="-110">x=0, setWaiting()</label>
		</transition>
		<transition id="id43">
			<source ref="id16"/>
			<target ref="id19"/>
			<label kind="guard" x="-578" y="34">isExitNear(pos[id].x, pos[id].y)</label>
			<label kind="assignment" x="-586" y="51">grid[pos[id].y][pos[id].x] = EMPTY</label>
			<nail x="-433" y="34"/>
		</transition>
		<transition id="id44">
			<source ref="id16"/>
			<target ref="id18"/>
			<label kind="guard" x="-450" y="-68">!isFireNear(pos[id].x, pos[id].y) &amp;&amp;
!isExitNear(pos[id].x, pos[id].y)</label>
		</transition>
		<transition id="id45">
			<source ref="id16"/>
			<target ref="id17"/>
			<label kind="guard" x="-841" y="-110">isFireNear(pos[id].x, pos[id].y) &amp;&amp;
!isExitNear(pos[id].x, pos[id].y)</label>
			<label kind="assignment" x="-841" y="-59">grid[pos[id].y][pos[id].x] = NEED</label>
			<nail x="-595" y="-67"/>
		</transition>
	</template>
	<template>
		<name x="5" y="5">Drone</name>
		<parameter>int id</parameter>
		<declaration>// Place local declarations here.
bool isMovingRight;
int distZR, distFR, nPNADetected, nSurvivorDetected, idFR = -1, idSurv = -1;
const pos_t  DEF_POS = {-1, -1};
pos_t posPNA = DEF_POS, posSurv = DEF_POS, posFR = DEF_POS;



/**
 * @brief Moves the drone in an horizontal line
 * This functions moves the drone on a horizontal patrol route, 
 * The starting direction depends on the drone's initial position  
 *
 * @param id the drone id
 */

void dronePatrol(int id) {
    if (posDrone[id].x &lt;= GRID_W/2)
        isMovingRight = true;
    else
        isMovingRight = false;
    // Check current direction and move accordingly
    if (isMovingRight) {
        // Move right
        if (posDrone[id].x &lt; GRID_W - 1) {
            posDrone[id].x++;
        } else {
            // Reached the right end, change direction to left
            isMovingRight = false;
            posDrone[id].x--;
        }
    } else {
        // Move left
        if (posDrone[id].x &gt; 0) {
            posDrone[id].x--;
        } else {
            // Reached the left end, change direction to right
            isMovingRight = true;
            posDrone[id].x++;
        }
    }
}

void checkSurroundings(int id){
    int dx,dy;
    int nx,ny;
    // Check the eight neighboring cells around the drone position
    for (dx = -1; dx &lt;= 1; dx++) {
        for (dy = -1; dy &lt;= 1; dy++) {
            // Skip the current cell (the drone's position)
            if (dx == 0 &amp;&amp; dy == 0) {
                //TODO CHECK THAT
            }
            nx = posDrone[id].x + dx;
            ny = posDrone[id].y + dy;
            // Check if the neighboring cell is within the grid bounds
            if (nx &gt;= 0 &amp;&amp; nx &lt; GRID_W &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; GRID_H) {
                pos_t newPos = {nx, ny};
                if (cell(newPos) == NEED){
                    posPNA = newPos;
                }
                else if(cell(newPos) == SURVIVOR){
                    posSurv = newPos;
                    idSurv = getIdFromPosCivilian(posSurv);
                }
                else if (cell(newPos) == FIRST_RESPONDER){
                    posFR = newPos;
                    idFR = getIdFromPosFirstResponder(posSurv);
                }
            }
        }
    }
}

//Functions used to check if a PNA/Survivor/First_responder has been detected during the surrouding check using the variables pos of each entity
bool isPNANearby(){
    if (posPNA == DEF_POS)
        return false;
return true;
}

bool isSurvNearby(){
    if (posSurv == DEF_POS)
        return false;
return true;
}

bool isFRNearby(){
    if (posFR == DEF_POS)
        return false;
return true;
}

//Function that resets all the data taken from the previous surrounding check in order to be ready for the next one
void resetPos(){
    
    posPNA = DEF_POS;
    posSurv = DEF_POS;
    posFR = DEF_POS;
    idFR = -1;
    idSurv = -1;
}

//Checks in the calling and helping table if the survivor detected by the drone is available or already busy
bool isSurvAvailable(){
    if(calling[idSurv] != DEF_POS || helping[idSurv] != DEF_POS)
        return false;
    else
        return true; 
}

bool isFRAvailable(){;
    if(FRHelping[idFR] == DEF_POS)
        return true;
    else
        return false;
}


void putSurvBusy(){
    calling[idSurv] = posPNA;
    
}


</declaration>
		<location id="id46" x="-526" y="-8">
			<name x="-560" y="-42">Initializer</name>
			<urgent/>
		</location>
		<location id="id47" x="348" y="144">
			<name x="365" y="136">Instruct_Zero_Responder</name>
		</location>
		<location id="id48" x="170" y="-8">
			<name x="195" y="-17">Search_closest_responder</name>
		</location>
		<location id="id49" x="357" y="-153">
			<name x="382" y="-161">Instruct_ZeroFirst_Responder</name>
		</location>
		<location id="id50" x="-110" y="-8">
			<name x="-161" y="17">PNA_Detected</name>
		</location>
		<location id="id51" x="-399" y="-8">
			<name x="-425" y="-42">Initial</name>
			<urgent/>
		</location>
		<location id="id52" x="-612" y="161">
		</location>
		<init ref="id46"/>
		<transition id="id53">
			<source ref="id47"/>
			<target ref="id51"/>
			<label kind="assignment" x="-102" y="246">resetPos()</label>
			<nail x="229" y="280"/>
			<nail x="-255" y="280"/>
			<nail x="-408" y="136"/>
		</transition>
		<transition id="id54">
			<source ref="id49"/>
			<target ref="id51"/>
			<label kind="assignment" x="-85" y="-280">resetPos()</label>
			<nail x="229" y="-297"/>
			<nail x="-255" y="-297"/>
			<nail x="-399" y="-161"/>
		</transition>
		<transition id="id55">
			<source ref="id52"/>
			<target ref="id51"/>
			<label kind="assignment" x="-586" y="161">checkSurroundings(id)</label>
			<nail x="-510" y="144"/>
			<nail x="-467" y="102"/>
		</transition>
		<transition id="id56">
			<source ref="id50"/>
			<target ref="id51"/>
			<label kind="guard" x="-348" y="-170">!isSurvNearby()</label>
			<label kind="assignment" x="-331" y="-195">resetPos()</label>
			<nail x="-272" y="-144"/>
		</transition>
		<transition id="id57">
			<source ref="id51"/>
			<target ref="id52"/>
			<label kind="guard" x="-680" y="25">!isPNANearby()</label>
			<label kind="assignment" x="-705" y="51">dronePatrol(id)</label>
			<nail x="-527" y="34"/>
			<nail x="-586" y="68"/>
		</transition>
		<transition id="id58">
			<source ref="id51"/>
			<target ref="id50"/>
			<label kind="guard" x="-331" y="-42">isPNANearby()</label>
		</transition>
		<transition id="id59">
			<source ref="id50"/>
			<target ref="id48"/>
			<label kind="guard" x="-110" y="-42">isSurvNearby() &amp;&amp; isSurvAvailable()</label>
		</transition>
		<transition id="id60">
			<source ref="id46"/>
			<target ref="id51"/>
		</transition>
		<transition id="id61">
			<source ref="id48"/>
			<target ref="id47"/>
			<label kind="guard" x="8" y="110">!isFRNearby() || !isFRAvailable()</label>
			<label kind="synchronisation" x="93" y="93">assist[idSurv]!</label>
		</transition>
		<transition id="id62">
			<source ref="id48"/>
			<target ref="id49"/>
			<label kind="guard" x="8" y="-153">isFRNearby() &amp;&amp; isFRAvailable()</label>
			<label kind="synchronisation" x="42" y="-170">callFIRST_RESPONDER[idSurv]!</label>
		</transition>
	</template>
	<system>// Place template instantiations here.
// List one or more processes to be composed into a system.

// System Declaration
system Civilian, FirstResponder;
</system>
	<queries>
		<query>
			<formula/>
			<comment/>
		</query>
	</queries>
</nta>
