<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>// Place global declarations here.

const int EMPTY = 0;
const int FIRE = 1;
const int EXIT = 2;
const int DRONE = 3;                //drones must not be placed on the grid with other entities because they're supposed to be able to hover over human entities (should not take room in the table)
const int FIRST_RESPONDER = 4;
const int SURVIVOR = 5;
const int NEED = 7;
const int CIVILIAN = 8;
// const int N = 5;

/*********GLOBAL SYSTEM PARAMETERS *****************/

const int GRID_W = 5; //grid width
const int GRID_H = 4; //grid height
const int N_CIVILIANS = 4;  // Total number of civilians
const int N_DRONES = 2; //Total number of drones 
const int N_FR = 2; // Total number of first responders
const int Tv = 20; //time for the civilian to die close to a fire
// todo remove const int Tfr = 5; //time to save a person
// todo remove const int Nv = 1; //Drone detection range
typedef int[0,N_CIVILIANS-1] id_zr;
typedef int[0,N_DRONES-1] id_dr;
typedef int[N_CIVILIANS,N_CIVILIANS+N_FR-1] id_fr;
typedef struct { int x, y; } pos_t;
const pos_t  DEF_POS = {-1, -1};

/********* VERIFICATION PARAMETERS *******************/

int Tscs = 10;
int N_perc = 40;   // meaning 30%


/********* VERIFICATION VARIABLES *******************/

clock global_time = 0;
int n_safe = 0; // n. of saved civilians

/*********GLOBAL VARIABLES*************************/

int grid[GRID_H][GRID_W];    // map considering role
// arrays used to put in relations ids with positions of entities (useful for drones too when contacting zero responders)
pos_t pos[N_CIVILIANS+N_FR];        // Array of coordinates of all civ+fr
pos_t posDrone[N_DRONES];

//todo remove int xNeed[GRID_H][GRID_W];   // X coordinate for need requests, xNeed[1][2] set to 5 indicates that the civilian found at coordinates (y=1,x=2) is in charge of saving the person in need found at x = 5  
//todo remove int yNeed[GRID_H][GRID_W];   // Y coordinate for need requests, --same-- at y = value

pos_t helping[N_CIVILIANS]; // helping {{1, 5}, {-1, -1}} means that civilian with id 0 is helping person found at coordinate x = 1 and y = 5 while civilian with id 1 is free
pos_t calling[N_CIVILIANS]; // calling {{1, 5}, {-1, -1}} means that civilian with id 0 is calling first responder found at coordinate x = 1 and y = 5 while civilian with id 1 is free
pos_t FRHelping[N_FR];      // same principles for first responders  

/*********GLOBAL VARIABLES*************************/

/*** CHANNELS *************************************/

chan assist[N_CIVILIANS]; // Channel used by drones to request survivors to assist
chan callFirstResponder[N_CIVILIANS]; //Channel used by drones to request survivors to call a first responder to help a person in need
chan assistDone[N_CIVILIANS+N_FR]; // Channel used by civilian when they're saved by a zero responder/first responder
broadcast chan starting;    // channel used from the initializer
broadcast chan dead[N_CIVILIANS];  // each victim use it to advise in case of death
chan wrong[N_CIVILIANS];

/*** CHANNELS *************************************/

/*** GLOBAL TYPES *********************************/



//...

/*** GLOBAL FUNCTIONS *************************************/

int cell(pos_t p) {
    return grid[p.y][p.x];
}

//Place the entity on the grid and register it in its respective array
void placeEntity(int id, int Y, int X, int entityType){
    if (entityType == FIRST_RESPONDER || entityType == CIVILIAN){
        grid[Y][X] = entityType;
        pos[id].x = X;
        pos[id].y = Y;
    }
    else if(entityType == DRONE){
        posDrone[id].x = X;
        posDrone[id].y = Y;
    }
}

void initCallingHelping(){
    int i;
    for(i=0;i&lt; N_CIVILIANS ;i++){
        helping[i]= DEF_POS;
        calling[i]= DEF_POS;
    }
}

void initFRHelping(){
    int i;
    for(i=0;i&lt; N_FR ;i++){
        FRHelping[i]= DEF_POS;
    }
}

void initializeGrid() {
    // Set all cells to EMPTY initially
    int i;
    for (i = 0; i &lt; GRID_W; i++) {
        int j;
        for (j = 0; j &lt; GRID_H; j++) {
            grid[j][i] = EMPTY;
        }
    }

    // Place exits in predefined positions
    grid[3][0] = EXIT;
    grid[3][4] = EXIT;

    // Place fire
    grid[1][1] = FIRE;
    grid[1][2] = FIRE;

    // Place Civilians
    placeEntity(0, 0, 1, CIVILIAN);
    placeEntity(1, 0, 3, CIVILIAN);
    placeEntity(2, 2, 0, CIVILIAN);
    placeEntity(3, 3, 3, CIVILIAN);

    // Place First Responders
    placeEntity(4, 2, 2, FIRST_RESPONDER);
    placeEntity(5, 3, 1, FIRST_RESPONDER);

    // Place Drones
    placeEntity(0, 0, 0, DRONE);
    placeEntity(1, 3, 4, DRONE);

    initCallingHelping();
    initFRHelping();
    n_safe = 0;
}

int abs_(int x) {
  if (x &lt; 0) {
    return -x;
  }
  return x;
}

/**
 * @brief Given coordinates x,y search in pos array to get the id of the civilian
 *
 * @param x The x-coordinate.
 * @param y The y-coordinate.
 * @return id of the specific entity.
 */
int getIdFromPosCivilian(pos_t posCiv){
   int i;
   for(i=0;i&lt;N_CIVILIANS;i++){
       if(pos[i].x== posCiv.x &amp;&amp; pos[i].y== posCiv.y){
         return i;
        }    
    }
    return -1;
}

/**
 * @brief Given coordinates x,y search in pos array to get the id of the first responder
 *
 * @param x The x-coordinate.
 * @param y The y-coordinate.
 * @return id of the specific entity.
 */
int getIdFromPosFirstResponder(pos_t posFR){
    int i;
    for(i=N_CIVILIANS;i&lt;N_CIVILIANS+N_FR;i++){
       if(pos[i].x== posFR.x &amp;&amp; pos[i].y== posFR.y){
         return i;
        }    
    }
    return -1;
}
</declaration>
	<template>
		<name>Initializer</name>
		<location id="id0" x="0" y="0">
			<name x="-10" y="-34">Initial</name>
			<committed/>
		</location>
		<location id="id1" x="0" y="119">
		</location>
		<init ref="id0"/>
		<transition id="id2">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="0" y="42">starting!</label>
			<label kind="assignment" x="0" y="59">initializeGrid()</label>
		</transition>
	</template>
	<template>
		<name>FirstResponder</name>
		<parameter>const id_fr id, int Tfr</parameter>
		<declaration>clock x;
int id_chan;

int idRescuing; // id person we're rescuing
int waiting; // distance from person in need when zr called
int zrToCommTo; // id zr to contact when finishing Tfr

/**
 * @brief Checks if a position is valid within the grid bounds.
 *
 * @param x The x-coordinate to check.
 * @param y The y-coordinate to check.
 * @return true if the position is valid, false otherwise.
 */
bool isValid(int x, int y) {
    if(x &gt;= 0 &amp;&amp; x &lt; GRID_W-1 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; GRID_H-1){
        return true;
    }
    return false;
}

/**
 * @brief Checks if a position is near fire.
 *
 * @param x The x-coordinate to check.
 * @param y The y-coordinate to check.
 * @return true if the position is near fire, false otherwise.
 */
bool isFireNear(int x, int y) {
    const int DX[4] = {-1, 1, 0, 0}; // Up, Down
    const int DY[4] = {0, 0, -1, 1}; // Left, Right
    int i;

    for (i = 0; i &lt; 4; i++) {
        int nx = x + DX[i];
        int ny = y + DY[i];

        if (isValid(nx, ny) &amp;&amp; grid[ny][nx] == FIRE) {
            return true;
        }
    }
    return false;
}
/**
 * @brief Checks if a position is near to a person in need.
 *
 * @param x The x-coordinate to check.
 * @param y The y-coordinate to check.
 * @return true if the position is near a person in need, false otherwise.
 */
bool isNeedNear(pos_t posNeed) {
    const int DX[4] = {-1, 1, 0, 0}; // Up, Down
    const int DY[4] = {0, 0, -1, 1}; // Left, Right
    int i;

    for (i = 0; i &lt; 4; i++) {
        int nx = posNeed.x + DX[i];
        int ny = posNeed.y + DY[i];

        if (isValid(nx, ny) &amp;&amp; grid[ny][nx] == NEED) {
            return true;
        }
    }
    return false;
}

void saveIdRescuing(pos_t posResc){
    const int DX[4] = {-1, 1, 0, 0}; // Up, Down
    const int DY[4] = {0, 0, -1, 1}; // Left, Right
    int i;

    for (i = 0; i &lt; 4; i++) {
        int nx = posResc.x + DX[i];
        int ny = posResc.y + DY[i];
        pos_t newPos = {nx, ny};
        if (isValid(nx, ny) &amp;&amp; grid[ny][nx] == NEED) {
            FRHelping[id-N_CIVILIANS].x= nx;
            FRHelping[id-N_CIVILIANS].y= ny;
            idRescuing = getIdFromPosCivilian(newPos);
        }
    }
}

bool isInCalling(){
   pos_t posFR = pos[id];
   int i;
   for(i=0;i&lt;N_CIVILIANS;i++){
      if(calling[i] == posFR){
            return true;   
     }
    }
    return false;
}

/**
 * @brief Moves a first responder to the center of the grid
 *
 * This function attempts to move a first responder (identified by `id`) towards the nearest edge of the grid.
 * The movement is restricted to horizontal or vertical directions and ensures that the new position is
 * not near fire. The function checks each step to determine if the new position is valid.
 *
 * @param id The identifier of the civilian to be moved.
 */
void move(int id) {
    // Current position of the civilian
    int current_x = pos[id].x;
    int current_y = pos[id].y;
    int new_x;
    int new_y;

    // Determine the distances to each side of the grid
    int dist_top = current_y;
    int dist_bottom = GRID_H - 1 - current_y;
    int dist_left = current_x;
    int dist_right = GRID_W - 1 - current_x;
    bool change;

    // Determine the direction going near the center
    int max_dist = 0;
    int direction = 0; // 0 for top, 1 for bottom, 2 for left, 3 for right

    if(isInCalling()){  change=1;}
    else change=0;

    if (dist_top &gt; max_dist &amp;&amp; grid[current_y - 1][current_x]!= FIRE ) {
        max_dist = dist_top;
        direction = 0;
    }
    if (dist_bottom &gt; max_dist &amp;&amp; grid[current_y + 1][current_x]!= FIRE ) {
        max_dist = dist_bottom;
        direction = 1;
    }
    if (dist_left &gt; max_dist &amp;&amp; grid[current_y][current_x-1]!= FIRE) {
        max_dist = dist_left;
        direction = 2;
    }
    if (dist_right &gt; max_dist &amp;&amp; grid[current_y][current_x+1]!= FIRE) {
        max_dist = dist_right;
        direction = 3;
    }

    new_x = current_x;
    new_y = current_y;

    // Move in the direction of the nearest side
    if (direction == 0) {
        // Move up
        new_y = current_y - 1;
    } else if (direction == 1) {
        // Move down
        new_y = current_y + 1;
    } else if (direction == 2) {
        // Move left
        new_x = current_x - 1;
    } else if (direction == 3) {
        // Move right
        new_x = current_x + 1;
     
    }

    // Check if the new position is valid and not near fire
    if (new_x &gt;= 0 &amp;&amp; new_x &lt; GRID_W &amp;&amp; new_y &gt;= 0 &amp;&amp; new_y &lt; GRID_H &amp;&amp; change==0) {
        if (grid[new_y][new_x] == EMPTY) {
            pos[id].x = new_x;
            pos[id].y = new_y;
            grid[current_y][current_x] = EMPTY;
            grid[new_y][new_x] = FIRST_RESPONDER; //update the grid
        }
    }
    
}

/**
 * @brief Calculates the Manhattan distance of a fr to the specified destination.
 *
 * This function calculates the Manhattan distance from the fr's current position
 * to the specified destination (destx, desty).
 *
 * @param id The identifier of the civilian.
 * @param dest The position of the destination.
 * @return The Manhattan distance to the destination.
 */
int calculateDistance(int id, pos_t dest) {
    // Current position of the civilian
    pos_t current_pos = pos[id];

    // Calculate Manhattan distance
    int distance = abs(current_pos.x - dest.x) + abs(current_pos.y - dest.y);

    return distance;
}



int getID_CHAN(){
    return id_chan;
}

bool differentPerson(){
   pos_t pos_rescue;
    pos_t posFR = pos[id];
   int i;
   for(i=0;i&lt;N_CIVILIANS;i++){
      if(calling[i] == posFR){
            pos_rescue = helping[i];   
     }
    }
    i = getIdFromPosCivilian(pos_rescue);
    if( idRescuing == i){ return false;}
    return true;
}


void setWaiting(pos_t posFR){
   pos_t pos_rescue;
   int i;
   for(i=0;i&lt;N_CIVILIANS;i++){
      if(calling[i] == posFR){
            pos_rescue = helping[i];
            FRHelping[id-N_CIVILIANS].x= pos_rescue.x;
            FRHelping[id-N_CIVILIANS].y= pos_rescue.y;
            zrToCommTo = i;     
     }
    } 
   waiting = abs(calculateDistance(id,pos_rescue));
}

void setFRFree(int id){
    FRHelping[id_chan] = DEF_POS;
}</declaration>
		<location id="id3" x="8" y="0">
			<name x="-2" y="-34">Initial</name>
			<label kind="invariant" x="-2" y="17">x&lt;=Tv</label>
		</location>
		<location id="id4" x="-391" y="0">
			<name x="-442" y="-34">Rescue_person</name>
			<label kind="invariant" x="-401" y="17">x&lt;=Tfr</label>
		</location>
		<location id="id5" x="654" y="0">
			<name x="644" y="-34">Called</name>
			<label kind="invariant" x="644" y="17">x&lt;=waiting</label>
		</location>
		<location id="id6" x="654" y="178">
			<label kind="invariant" x="644" y="195">x&lt;=Tfr</label>
		</location>
		<location id="id7" x="229" y="-93">
			<name x="219" y="-127">Initializer</name>
		</location>
		<location id="id8" x="-34" y="-289">
			<label kind="invariant" x="-44" y="-272">x&lt;=Tfr</label>
		</location>
		<location id="id9" x="42" y="178">
			<committed/>
		</location>
		<location id="id10" x="-136" y="-212">
			<committed/>
		</location>
		<location id="id11" x="-263" y="161">
			<name x="-273" y="127">End</name>
		</location>
		<init ref="id7"/>
		<transition id="id12">
			<source ref="id3"/>
			<target ref="id11"/>
			<label kind="guard" x="-212" y="119">x&gt;=Tv</label>
			<nail x="-51" y="119"/>
			<nail x="-246" y="119"/>
		</transition>
		<transition id="id13">
			<source ref="id6"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="391" y="102">dead[idRescuing]?</label>
			<label kind="assignment" x="442" y="119">setFRFree(id)</label>
			<nail x="280" y="102"/>
			<nail x="93" y="102"/>
		</transition>
		<transition id="id14">
			<source ref="id10"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="-119" y="-204">wrong[zrToCommTo]!</label>
		</transition>
		<transition id="id15">
			<source ref="id8"/>
			<target ref="id10"/>
			<label kind="guard" x="-297" y="-280">x==Tfr &amp;&amp; !differentPerson()</label>
			<label kind="synchronisation" x="-289" y="-263">assistDone[idRescuing]!</label>
			<label kind="assignment" x="-272" y="-246">x=0,setFRFree(id)</label>
		</transition>
		<transition id="id16">
			<source ref="id6"/>
			<target ref="id9"/>
			<label kind="guard" x="212" y="204">x&gt;=Tfr</label>
			<label kind="synchronisation" x="145" y="186">assistDone[zrToCommTo]!</label>
			<label kind="assignment" x="229" y="221">x=0</label>
		</transition>
		<transition id="id17">
			<source ref="id9"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="-195" y="136">assistDone[idRescuing]!</label>
			<label kind="assignment" x="-110" y="153">setFRFree(id)</label>
			<nail x="8" y="178"/>
		</transition>
		<transition id="id18">
			<source ref="id8"/>
			<target ref="id5"/>
			<label kind="guard" x="204" y="-331">x==Tfr &amp;&amp; differentPerson()</label>
			<label kind="synchronisation" x="178" y="-314">assistDone[idRescuing]!</label>
			<label kind="assignment" x="178" y="-289">x=0</label>
			<nail x="654" y="-289"/>
		</transition>
		<transition id="id19">
			<source ref="id4"/>
			<target ref="id8"/>
			<label kind="guard" x="-645" y="-34">x&lt;Tfr</label>
			<label kind="synchronisation" x="-527" y="-314">assistDone[id]?</label>
			<label kind="assignment" x="-645" y="0">setWaiting(pos[id])</label>
			<nail x="-663" y="0"/>
			<nail x="-663" y="-289"/>
		</transition>
		<transition id="id20">
			<source ref="id4"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="-323" y="-161">dead[idRescuing]?</label>
			<label kind="assignment" x="-323" y="-144">x=0, setFRFree(id)</label>
			<nail x="-391" y="-119"/>
			<nail x="-119" y="-119"/>
		</transition>
		<transition id="id21">
			<source ref="id4"/>
			<target ref="id3"/>
			<label kind="guard" x="-212" y="51">x&gt;=Tfr</label>
			<label kind="synchronisation" x="-306" y="93">assistDone[idRescuing]!</label>
			<label kind="assignment" x="-297" y="76">move(id),x=0, setFRFree(id)</label>
			<nail x="-323" y="76"/>
			<nail x="-51" y="76"/>
		</transition>
		<transition id="id22">
			<source ref="id5"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="127" y="110">dead[idRescuing]?</label>
			<label kind="assignment" x="144" y="127">setFRFree(id)</label>
			<nail x="289" y="102"/>
			<nail x="93" y="102"/>
		</transition>
		<transition id="id23">
			<source ref="id7"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="110" y="-68">starting?</label>
		</transition>
		<transition id="id24">
			<source ref="id5"/>
			<target ref="id6"/>
			<label kind="guard" x="663" y="68">x&gt;= waiting</label>
			<label kind="assignment" x="663" y="85">x=0</label>
		</transition>
		<transition id="id25">
			<source ref="id3"/>
			<target ref="id5"/>
			<label kind="synchronisation" x="178" y="0">assistDone[id]?</label>
			<label kind="assignment" x="161" y="17">x=0,setWaiting(pos[id])</label>
		</transition>
		<transition id="id26">
			<source ref="id3"/>
			<target ref="id3"/>
			<label kind="guard" x="-68" y="-161">!isNeedNear(pos[id])</label>
			<label kind="assignment" x="0" y="-144">move(id)</label>
			<nail x="-42" y="-119"/>
			<nail x="85" y="-119"/>
		</transition>
		<transition id="id27">
			<source ref="id3"/>
			<target ref="id4"/>
			<label kind="guard" x="-306" y="-25">isNeedNear(pos[id])</label>
			<label kind="assignment" x="-323" y="0">x=0,saveIdRescuing(pos[id])</label>
		</transition>
	</template>
	<template>
		<name>Civilian</name>
		<parameter>const id_zr id,int Tzr</parameter>
		<declaration>clock x;
int waitingHelping;
int waitingFR;
int idFRtoCall; //id of the first responder the current civilian is calling



/**
 * @brief Checks if a position is valid within the grid bounds.
 *
 * @param x The x-coordinate to check.
 * @param y The y-coordinate to check.
 * @return true if the position is valid, false otherwise.
 */
bool isValid(int x, int y) {
    return x &gt;= 0 &amp;&amp; x &lt; GRID_W-1 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; GRID_H-1;
}


bool isFRAvailable(int id){;
    if(FRHelping[id-N_CIVILIANS] == DEF_POS)
        return true;
    else
        return false;
}


/**
 * @brief Checks if a position is near fire.
 *
 * @param x The x-coordinate to check.
 * @param y The y-coordinate to check.
 * @return true if the position is near fire, false otherwise.
 */
bool isFireNear(int x, int y) {
    const int DX[4] = {-1, 1, 0, 0}; // Up, Down
    const int DY[4] = {0, 0, -1, 1}; // Left, Right
    int i;

    for (i = 0; i &lt; 4; i++) {
        int nx = x + DX[i];
        int ny = y + DY[i];

        if (isValid(nx, ny) &amp;&amp; grid[ny][nx] == FIRE) {
            return true;
        }
    }
    return false;
}

/** Not sure if this function is necessary
 * @brief Checks if a zero responder is near the person to help.
 *
 * @param id the id of the zero responder.
 * @param x The x-coordinate to check.
 * @param y The y-coordinate to check.
 * @return true if the position is near the person to help, false otherwise.
 */
bool isNeedNear(int id) {

    if(abs_(helping[id].x - pos[id].x) == 1 || abs_(helping[id].y - pos[id].y) == 1) return true;

    return false;
}

/** Not sure if this function is necessary
 * @brief Checks if a zero responder is near the person to help.
 *
 * @param id the id of the zero responder.
 * @param x The x-coordinate to check.
 * @param y The y-coordinate to check.
 * @return true if the position is near the person to help, false otherwise.
 */
bool isFirstResponderNear(int id) {

    if(abs_(calling[id].x - pos[id].x) == 1 || abs_(calling[id].y - pos[id].y) == 1) return true;

    return false;
}

/**
 * @brief Moves a civilian to the nearest side of the grid if the next cell is not near the fire.
 *
 * This function attempts to move a civilian (identified by `id`) towards the nearest edge of the grid.
 * The movement is restricted to horizontal or vertical directions and ensures that the new position is
 * not near fire. The function checks each step to determine if the new position is valid.
 *
 * @param id The identifier of the civilian to be moved.
 */
void move(int id) { //todo improve this by making the civilian walk along the edge of the grid
    // Current position of the civilian
    int current_x = pos[id].x;
    int current_y = pos[id].y;
    int new_x;
    int new_y;

    // Determine the distances to each side of the grid
    int dist_top = current_y;
    int dist_bottom = GRID_H - 1 - current_y;
    int dist_left = current_x;
    int dist_right = GRID_W - 1 - current_x;

    // Determine the nearest side of the grid without using the min function
    int min_dist = dist_top;
    int direction = 0; // 0 for top, 1 for bottom, 2 for left, 3 for right

    if (dist_bottom &lt; min_dist) {
        min_dist = dist_bottom;
        direction = 1;
    }
    if (dist_left &lt; min_dist) {
        min_dist = dist_left;
        direction = 2;
    }
    if (dist_right &lt; min_dist) {
        min_dist = dist_right;
        direction = 3;
    }

    new_x = current_x;
    new_y = current_y;

    // Move in the direction of the nearest side
    if (direction == 0) {
        // Move up
        new_y = current_y - 1;
    } else if (direction == 1) {
        // Move down
        new_y = current_y + 1;
    } else if (direction == 2) {
        // Move left
        new_x = current_x - 1;
    } else if (direction == 3) {
        // Move right
        new_x = current_x + 1;
    }

    // Check if the new position is valid and not near fire
    if (new_x &gt;= 0 &amp;&amp; new_x &lt; GRID_W &amp;&amp; new_y &gt;= 0 &amp;&amp; new_y &lt; GRID_H) {
        if (grid[new_y][new_x] == EMPTY &amp;&amp; !isFireNear(new_x, new_y)) {
            pos[id].x = new_x;
            pos[id].y = new_y;
            grid[current_y][current_x] = EMPTY;
            grid[new_y][new_x] = SURVIVOR; //update the grid
        }
    }
}


/**
 * @brief Calculates the Manhattan distance of a civilian to the specified destination.
 *
 * This function calculates the Manhattan distance from the civilian's current position
 * to the specified destination (destx, desty).
 *
 * @param id The identifier of the civilian.
 * @param dest The position of the destination.
 * @return The Manhattan distance to the destination.
 */
int calculateDistance(int id, pos_t dest) {
    // Current position of the civilian
    pos_t current_pos;
    int distance;

    current_pos.x = pos[id].x;
    current_pos.y = pos[id].y;

    // Calculate Manhattan distance
    distance = abs(current_pos.x - dest.x) + abs(current_pos.y - dest.y);

    return distance;
}


/*
    checks if the entity is near the exit
*/
bool isExitNear(int x, int y) {
    // Directions for vertical and horizontal neighbors only
    int dx[4] = {-1, 1, 0, 0}; // Up, Down
    int dy[4] = {0, 0, -1, 1}; // Left, Right

    int i;
    for (i=0; i &lt; 4; i++) {
        int nx = x + dx[i];
        int ny = y + dy[i];

        // Check if the new coordinates are within the grid bounds
        if (nx &gt;= 0 &amp;&amp; ny &lt; GRID_H &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; GRID_W) {
            if (grid[ny][nx] == EXIT) {
                return true;
            }
        }
    }

    return false; // No exit found nearby
}

/**
 * @brief sets time it takes for a civilian to reach the person in need
 */
void setWaiting(){
   waitingHelping = abs(calculateDistance(id,helping[id]));
}

/**
 * @brief sets time it takes for a civilian to reach the first responder and the id of the fr to call
 */
void setWaitingfr() {
    pos_t f;
    f.x = calling[id].x;
    f.y = calling[id].y;
    waitingFR = abs(calculateDistance(id, f));
    idFRtoCall = abs(getIdFromPosFirstResponder(f));
}

/**
 * @brief sets the survivor's calling coordinates to default in both the calling and the helping table
 */
void setSurvFree(int id){
    calling[id] = DEF_POS;
    helping[id] = DEF_POS;
}

</declaration>
		<location id="id28" x="-493" y="-68">
			<name x="-544" y="-59">Initial</name>
			<committed/>
		</location>
		<location id="id29" x="-926" y="-68">
			<name x="-960" y="-102">InNeed</name>
			<label kind="invariant" x="-936" y="-51">x&lt;=Tv</label>
		</location>
		<location id="id30" x="-102" y="-68">
			<name x="-136" y="-102">Survivor</name>
			<label kind="invariant" x="-85" y="-59">x&lt;=Tv</label>
		</location>
		<location id="id31" x="-238" y="110">
			<name x="-263" y="76">Saved</name>
		</location>
		<location id="id32" x="238" y="-68">
			<name x="179" y="-102">ZeroResponder</name>
			<label kind="invariant" x="195" y="-59">x &lt;= waitingHelping</label>
		</location>
		<location id="id33" x="-926" y="-229">
			<name x="-943" y="-263">Dead</name>
		</location>
		<location id="id34" x="238" y="110">
			<label kind="invariant" x="255" y="101">x &lt;= Tzr</label>
		</location>
		<location id="id35" x="-501" y="-161">
			<name x="-511" y="-195">Initializer</name>
		</location>
		<location id="id36" x="858" y="-467">
			<name x="756" y="-501">CallingFirstResponder</name>
			<label kind="invariant" x="799" y="-450">x &lt;= waitingFR</label>
		</location>
		<location id="id37" x="858" y="-127">
			<name x="875" y="-152">ReachedFirstResponder</name>
		</location>
		<location id="id38" x="238" y="-255">
			<committed/>
		</location>
		<init ref="id35"/>
		<transition id="id39">
			<source ref="id30"/>
			<target ref="id31"/>
			<label kind="guard" x="-194" y="17">x&gt;=Tv</label>
			<label kind="assignment" x="-187" y="-17">grid[pos[id].y][pos[id].x] = EMPTY,n_safe=n_safe+1</label>
			<nail x="-102" y="34"/>
			<nail x="-212" y="68"/>
		</transition>
		<transition id="id40">
			<source ref="id37"/>
			<target ref="id31"/>
			<label kind="synchronisation" x="221" y="178">assistDone[id]?</label>
			<label kind="assignment" x="144" y="195">x=0,grid[pos[id].y][pos[id].x] = EMPTY,n_safe=n_safe+1</label>
			<nail x="858" y="170"/>
			<nail x="-136" y="170"/>
		</transition>
		<transition id="id41">
			<source ref="id37"/>
			<target ref="id38"/>
			<label kind="synchronisation" x="510" y="-187">wrong[id]?</label>
			<label kind="assignment" x="493" y="-170">setSurvFree(id)</label>
			<nail x="645" y="-191"/>
			<nail x="331" y="-191"/>
		</transition>
		<transition id="id42">
			<source ref="id38"/>
			<target ref="id30"/>
			<label kind="assignment" x="-59" y="-289">grid[pos[id].y][pos[id].x] = SURVIVOR</label>
			<nail x="0" y="-255"/>
		</transition>
		<transition id="id43">
			<source ref="id32"/>
			<target ref="id38"/>
			<label kind="synchronisation" x="102" y="-161">dead[getIdFromPosCivilian(helping[id])]?</label>
			<label kind="assignment" x="255" y="-144">setSurvFree(id)</label>
			<nail x="238" y="-153"/>
		</transition>
		<transition id="id44">
			<source ref="id35"/>
			<target ref="id28"/>
			<label kind="synchronisation" x="-578" y="-153">starting?</label>
		</transition>
		<transition id="id45">
			<source ref="id34"/>
			<target ref="id31"/>
			<label kind="guard" x="-110" y="51">x&gt;=Tzr</label>
			<label kind="assignment" x="-195" y="68">x = 0,
grid[pos[id].y][pos[id].x] = EMPTY,n_safe=n_safe+1</label>
		</transition>
		<transition id="id46">
			<source ref="id32"/>
			<target ref="id34"/>
			<label kind="guard" x="246" y="-8">x&gt;= waitingHelping</label>
			<label kind="synchronisation" x="246" y="26">assistDone[getIdFromPosCivilian(helping[id])]!</label>
			<label kind="assignment" x="246" y="9">x=0</label>
		</transition>
		<transition id="id47">
			<source ref="id30"/>
			<target ref="id28"/>
			<label kind="assignment" x="-391" y="-178">move(id)</label>
			<nail x="-153" y="-153"/>
			<nail x="-433" y="-153"/>
		</transition>
		<transition id="id48">
			<source ref="id29"/>
			<target ref="id31"/>
			<label kind="synchronisation" x="-799" y="68">assistDone[id]?</label>
			<label kind="assignment" x="-860" y="84">grid[pos[id].y][pos[id].x] = EMPTY, n_safe=n_safe+1</label>
			<label kind="comments" x="-766" y="119">when helped and time for helping finishes</label>
			<nail x="-902" y="110"/>
		</transition>
		<transition id="id49">
			<source ref="id29"/>
			<target ref="id33"/>
			<label kind="guard" x="-918" y="-195">x &gt;= Tv</label>
			<label kind="synchronisation" x="-918" y="-161">dead[id]!</label>
			<label kind="assignment" x="-918" y="-178">grid[pos[id].y][pos[id].x] = EMPTY, x=0</label>
		</transition>
		<transition id="id50">
			<source ref="id30"/>
			<target ref="id36"/>
			<label kind="synchronisation" x="59" y="-493">callFirstResponder[id]?</label>
			<label kind="assignment" x="76" y="-510">x:=0, setWaitingfr()</label>
			<nail x="-102" y="-467"/>
		</transition>
		<transition id="id51">
			<source ref="id30"/>
			<target ref="id32"/>
			<label kind="synchronisation" x="17" y="-93">assist[id]?</label>
			<label kind="assignment" x="-8" y="-110">x=0, setWaiting()</label>
		</transition>
		<transition id="id52">
			<source ref="id28"/>
			<target ref="id31"/>
			<label kind="guard" x="-586" y="8">isExitNear(pos[id].x, pos[id].y)</label>
			<label kind="assignment" x="-586" y="25">grid[pos[id].y][pos[id].x] = EMPTY,n_safe=n_safe+1</label>
			<nail x="-433" y="34"/>
		</transition>
		<transition id="id53">
			<source ref="id28"/>
			<target ref="id30"/>
			<label kind="guard" x="-442" y="-68">!isFireNear(pos[id].x, pos[id].y) &amp;&amp;
!isExitNear(pos[id].x, pos[id].y)</label>
			<label kind="assignment" x="-459" y="-93">grid[pos[id].y][pos[id].x] = SURVIVOR</label>
		</transition>
		<transition id="id54">
			<source ref="id28"/>
			<target ref="id29"/>
			<label kind="guard" x="-841" y="-110">isFireNear(pos[id].x, pos[id].y) &amp;&amp;
!isExitNear(pos[id].x, pos[id].y)</label>
			<label kind="assignment" x="-841" y="-59">grid[pos[id].y][pos[id].x] = NEED</label>
			<nail x="-595" y="-67"/>
		</transition>
		<transition id="id55">
			<source ref="id37"/>
			<target ref="id38"/>
			<label kind="synchronisation" x="288" y="-254">dead[getIdFromPosCivilian(helping[id])]?</label>
			<label kind="assignment" x="374" y="-238">setSurvFree(id)</label>
			<nail x="705" y="-254"/>
		</transition>
		<transition id="id56">
			<source ref="id36"/>
			<target ref="id38"/>
			<label kind="synchronisation" x="229" y="-398">dead[getIdFromPosCivilian(helping[id])]?</label>
			<label kind="assignment" x="357" y="-416">setSurvFree(id)</label>
			<nail x="739" y="-373"/>
			<nail x="365" y="-373"/>
		</transition>
		<transition id="id57">
			<source ref="id36"/>
			<target ref="id37"/>
			<label kind="guard" x="867" y="-340">x &gt;= waitingFR</label>
			<label kind="synchronisation" x="867" y="-297">assistDone[idFRtoCall]!</label>
			<label kind="assignment" x="867" y="-323">setWaiting()</label>
		</transition>
	</template>
	<template>
		<name x="5" y="5">Drone</name>
		<parameter>const id_dr id, int Nv</parameter>
		<declaration>
/*
    Acronyms:
    PNA =&gt; person in need of assistance
*/

// local declarations
bool isMovingRight;
int distZR, distFR, nPNADetected, nSurvivorDetected, idFR = -1, idSurv = -1;
pos_t posPNA = DEF_POS, posSurv = DEF_POS, posFR = DEF_POS;
bool movingRight, movingUp; //determine if the drone is moving right or up 

/**
 * @brief Check if the detected survivor is available 
 * 
 *
 * @return bool confirming or not the availability of the survivor 
 */
bool isSurvAvailable(int id){
    if(calling[id] != DEF_POS || helping[id] != DEF_POS)
        return false;
    else
        return true; 
}

/**
 * @brief Check if the detected First Responder is available 
 * 
 *
 * @return bool confirming or not the availability of the First Responder 
 */
bool isFRAvailable(int id){;
    if(FRHelping[id-N_CIVILIANS] == DEF_POS)
        return true;
    else
        return false;
}

/**
 * @brief Checks if the PNA is being rescued by a zero responder or a First Responder 
 * Checks in the survivor helping table and in the first responder helping table if the PNA is being rescued 
 *
 * @return bool confirming or not if the PNA is being rescued or not  
 */
bool isPNABeingHelped(pos_t posPNA){
    int i,j;
    for(i=0;i&lt;N_CIVILIANS;i++){
       if(helping[i] == posPNA){
         return true;
        }    
    }
    for(j = 0; i &lt; N_FR; j++){
       if(FRHelping[j] == posPNA){
         return true;
        }   
    }
    return false;
}

/**
 * @brief Check all cells within the Manhattan distance Nv from the drone position
 * Registers first responders and survivors only if they are available 
 * Registers PNA only if its not being rescued already
 * @param id the drone id 
 */
    // 
void checkSurroundings(int id) {
    int dx, dy;
    int nx, ny; //new x and new y
    for (dx = -Nv; dx &lt;= Nv; dx++) {
        for (dy = -Nv; dy &lt;= Nv; dy++) {
            
            nx = posDrone[id].x + dx;
            ny = posDrone[id].y + dy;
            if (nx &gt;= 0 &amp;&amp; nx &lt; GRID_W &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; GRID_H) {
                pos_t newPos = {nx, ny};
                if (cell(newPos) == NEED) {
                    if (!isPNABeingHelped(newPos))
                        posPNA = newPos;
                } else if (cell(newPos) == SURVIVOR || cell(newPos) == CIVILIAN) {
                    if (isSurvAvailable(getIdFromPosCivilian(newPos))){
                        posSurv = newPos;
                        idSurv = getIdFromPosCivilian(posSurv);
                    }
                } else if (cell(newPos) == FIRST_RESPONDER) {
                    if (isFRAvailable(getIdFromPosFirstResponder(newPos))){
                        posFR = newPos;
                        idFR = getIdFromPosFirstResponder(posFR); 
                    }
                }
            }
        }
    }
}

/**
 * @brief Moves the drone in a cyclic pattern around its assigned portion of the grid
 * This function moves the drone in a cyclic patrol route,
 * covering its assigned portion of the grid efficiently.
 *
 * @param id the drone id
 */
void dronePatrol(int id) {
    // Determine the portion of the grid this drone will patrol
    int portionSize = GRID_W / N_DRONES;
    int startX = id * portionSize;
    int endX = startX + portionSize - 1;

    // Ensure the drone is within its assigned portion
    if (posDrone[id].x &lt; startX) {
        posDrone[id].x = startX;
    } else if (posDrone[id].x &gt; endX) {
        posDrone[id].x = endX;
    }

    // Check if the drone is at the right edge of its portion
    if (movingRight) {
        if (posDrone[id].x &lt; endX) {
            posDrone[id].x++;
        } else {
            // Reached the right edge, change direction and move vertically
            movingRight = false;
            if (movingUp) {
                if (posDrone[id].y &gt; 0) {
                    posDrone[id].y--;
                } else {
                    movingUp = false;
                    posDrone[id].y++;
                }
            } else {
                if (posDrone[id].y &lt; GRID_H - 1) {
                    posDrone[id].y++;
                } else {
                    movingUp = true;
                    posDrone[id].y--;
                }
            }
        }
    } else {
        // Check if the drone is at the left edge of its portion
        if (posDrone[id].x &gt; startX) {
            posDrone[id].x--;
        } else {
            // Reached the left edge, change direction and move vertically
            movingRight = true;
            if (movingUp) {
                if (posDrone[id].y &gt; 0) {
                    posDrone[id].y--;
                } else {
                    movingUp = false;
                    posDrone[id].y++;
                }
            } else {
                if (posDrone[id].y &lt; GRID_H - 1) {
                    posDrone[id].y++;
                } else {
                    movingUp = true;
                    posDrone[id].y--;
                }
            }
        }
    }

    checkSurroundings(id);
}





/**
 * @brief Check if a PNA has been detected during the surrouding check using the registered variables pos of each entity
 * 
 *
 * @return bool confirming or not the presence of a PNA
 */
bool isPNANearby(){
    if (posPNA == DEF_POS)
        return false;
return true;
}

/**
 * @brief Check if a Survivor has been detected during the surrouding check using the registered variables pos of each entity
 * 
 *
 * @return bool confirming or not the presence of a Survivor
 */
bool isSurvNearby(){
    if (posSurv == DEF_POS) 
        return false;
return true;
}

/**
 * @brief Check if a First Responder has been detected during the surrouding check using the registered variables pos of each entity
 * 
 *
 * @return bool confirming or not the presence of a First Responder
 */
bool isFRNearby(){
    if (posFR == DEF_POS)
        return false;
return true;
}

/**
 * @brief Register the survivor as busy in the calling table
 * 
 */
void setSurvBusyCalling(){
    calling[idSurv] = posFR;
    helping[idSurv] = posPNA;    
}

/**
 * @brief Register the survivor as busy in the helping table
 * 
 */
void setSurvBusyHelping(){
    helping[idSurv] = posPNA;  
}

/**
 * @brief Register the first responder as busy in the helping table
 * 
 */
void setFRBusyHelping(){
    FRHelping[idFR-N_CIVILIANS] = posPNA;
}


/**
 * @brief Resets all the data (pos and booleans) taken from the previous surrounding check in order to be ready for the next one
 * 
 */
void resetData(){
    
    posPNA = DEF_POS;
    posSurv = DEF_POS;
    posFR = DEF_POS;
    idFR = -1;
    idSurv = -1;
}


</declaration>
		<location id="id58" x="-526" y="-8">
			<name x="-560" y="-42">Initializer</name>
		</location>
		<location id="id59" x="170" y="-8">
			<name x="195" y="-17">Search_closest_responder</name>
			<committed/>
		</location>
		<location id="id60" x="-110" y="-8">
			<name x="-161" y="17">PNA_Detected</name>
			<committed/>
		</location>
		<location id="id61" x="-399" y="-8">
			<name x="-425" y="-42">Initial</name>
			<urgent/>
		</location>
		<init ref="id58"/>
		<transition id="id62">
			<source ref="id58"/>
			<target ref="id61"/>
		</transition>
		<transition id="id63">
			<source ref="id60"/>
			<target ref="id61"/>
			<label kind="guard" x="-306" y="-136">!isSurvNearby()</label>
			<label kind="assignment" x="-289" y="-153">resetData()</label>
			<nail x="-238" y="-102"/>
		</transition>
		<transition id="id64">
			<source ref="id61"/>
			<target ref="id61"/>
			<label kind="guard" x="-680" y="25">!isPNANearby()</label>
			<label kind="assignment" x="-705" y="51">dronePatrol(id)</label>
			<nail x="-544" y="51"/>
			<nail x="-484" y="110"/>
		</transition>
		<transition id="id65">
			<source ref="id61"/>
			<target ref="id60"/>
			<label kind="guard" x="-306" y="-34">isPNANearby()</label>
		</transition>
		<transition id="id66">
			<source ref="id60"/>
			<target ref="id59"/>
			<label kind="guard" x="-34" y="-34">isSurvNearby()</label>
		</transition>
		<transition id="id67">
			<source ref="id59"/>
			<target ref="id61"/>
			<label kind="guard" x="-25" y="119">!isFRNearby()</label>
			<label kind="synchronisation" x="-25" y="102">assist[idSurv]!</label>
			<label kind="assignment" x="-25" y="136">setSurvBusyHelping(),
resetData()</label>
			<nail x="170" y="187"/>
			<nail x="-399" y="187"/>
		</transition>
		<transition id="id68">
			<source ref="id59"/>
			<target ref="id61"/>
			<label kind="guard" x="-68" y="-238">isFRNearby()</label>
			<label kind="synchronisation" x="-68" y="-255">callFirstResponder[idSurv]!</label>
			<label kind="assignment" x="-68" y="-221">setSurvBusyCalling(),
setFRBusyHelping(),
resetData()</label>
			<nail x="170" y="-272"/>
			<nail x="-399" y="-272"/>
		</transition>
	</template>
	<system>// Place template instantiations here.
// List one or more processes to be composed into a system.
// System Declaration
C0 := Civilian(0, 1);
C1 := Civilian(1, 3);
C2 := Civilian(2, 2);
C3 := Civilian(3, 4);

F4 := FirstResponder(4, 2);
F5 := FirstResponder(5, 4);

D0 := Drone(0, 4);
D1 := Drone(1, 4);

system C0, C1, C2, C3, F4, F5, Initializer, D0, D1;
</system>
	<queries>
		<option key="--statespace-consumption" value="2"/>
		<option key="--diagnostic" value="0"/>
		<query>
			<formula>E&lt;&gt; (global_time &lt;= Tscs and n_safe &gt;= (N_CIVILIANS * N_perc / 100))</formula>
			<comment>It is possible for a percentage N% of all civilians to reach a safe state within time Tscs</comment>
			<option key="--diagnostic" value="1"/>
			<result outcome="success" type="quality" timestamp="2024-07-12 18:36:27 +0200">
				<option key="--diagnostic" value="1"/>
			</result>
		</query>
		<query>
			<formula>A&lt;&gt; (global_time &gt;= Tscs imply n_safe &gt;= (N_CIVILIANS * N_perc / 100))</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-07-12 17:36:27 +0200">
				<option key="--statespace-consumption" value="2"/>
				<option key="--diagnostic" value="0"/>
			</result>
		</query>
		<query>
			<formula>A[] (global_time &gt;= Tscs imply n_safe &gt;= (N_CIVILIANS * N_perc / 100))</formula>
			<comment>a percentage N% of all civilians is always guaranteed to reach a safe state within time Tscs</comment>
			<option key="--diagnostic" value="0"/>
			<result outcome="success" type="quality" timestamp="2024-07-12 17:52:14 +0200">
				<option key="--diagnostic" value="0"/>
			</result>
		</query>
	</queries>
</nta>
